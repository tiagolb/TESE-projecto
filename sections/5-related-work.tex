%!TEX root = ../report.tex

% 
% Related work
% 
% (~17pgs)
\section{Related Work}
\label{sec:relatedWork}

This section describes the related work and is organized in three main parts. First, in order to better motivate our proposal, we discuss the existing security issues of a class of applications that can take advantage of a trusted output functionality: mobile health applications. In the second part of this section, we overview the state of the art of general-purpose mobile security mechanisms used to implement most secure sensitive applications, such as those described in the first part. We also explain why such mechanisms fall short in supporting secure output to these apps. Finally, the third part describes a specific class of security systems which, similarly to \emph{ViewZone}, leverage TrustZone to implement a variety of security solutions for mobile platforms.

\subsection{Studies in Mobile Health Security}
\label{sec:mhealth}

Medical data is highly profitable for malicious agents who can use it for medical identity theft, as it can be more valuable than credit card information. Generally, vulnerabilities which lead to sensitive data leakage originate from negligent development of healthcare systems. For this reason, regulatory laws such as the \ac{HIPAA} have been established. These laws comprise the standard for electronic healthcare transactions and must be followed by all developers when managing sensitive health data.

In the mobile context, data is even more exposed and vulnerable due to several reasons: \emph{(1)} inherent portability of these devices, \emph{(2)} sharing of information to third-party advertisers by device manufacturers or mobile app developers, \emph{(3)} unregulated management of sensitive medical information, specially because regulatory laws such as \ac{HIPAA} do not account for the mobile sector, and \emph{(4)} existence of security flaws in consumer device software, which can be exploited by malware. Such an exposure to attacks motivates the need for a security system capable of allowing applications to securely display and manage sensitive data.

The following subsections describe work done in assessing the security properties of commercial mobile health applications as to better understand the need for a secure content display capability. The first subsection describes a threat taxonomy for mHealth applications by Kotz~\cite{kotz2011threat}. The second and third subsections describe work done by He et al.~\cite{he2014security} through the analysis of three studies which answer the following questions: what are the potential attack surfaces, how widespread and how serious are these security threats.

\subsubsection{Threat Taxonomy for Mobile Health Applications}

Kotz~\cite{kotz2011threat} defines a threat taxonomy for mHealth and categorizes threats in three main categories: \emph{identity threats}, \emph{access threats} and \emph{disclosure threats}.

\emph{Identity threats} are described as a misuse of patient identities and include scenarios where a patient may lose (or share) their identity credentials, allowing malicious agents to access their respective \ac{PHR}. \emph{Insiders} (authorized \ac{PHR} users, staff of the \ac{PHR} organization or staff of other mHealth support systems) may also use patient identities for medical fraud or for medical identity theft, and \emph{outsiders} may be able to observe patient identity or location from communications.
%tempo verbal no their? nao entendi

\emph{Access threats} are described as unauthorized access to \ac{PHR} and include scenarios where the patient, which controls the data, allows broader-than-intended access or disclosure of information, \emph{insiders} who may snoop or modify patient data with malicious intent, and even \emph{outsiders} which, by breaking into patient records, may leak or modify this data.
% QUEREMOS RESOLVER ESTES

\emph{Disclosure threats} include scenarios where an adversary captures network packets in order to obtain sensitive health data. This problem can be mitigated by using strong encryption methods. But even if the network traffic is encrypted it is possible to analyse the traffic to determine its characteristics~\cite{wright2006inferring}. The adversary may also use physical or link layer fingerprinting methods to identify the device type and inject or selectively interfere with wireless frames.

Avancha et al.~\cite{avancha2012privacy} developed a privacy framework for privacy-sensitive mobile health systems. A developer should use the list of privacy properties provided by this article as a check-list to be considered in any design. But even these security properties are not sufficient to withstand an attack leveraged by a compromised operating system, which is an attack not explicitly described in the above taxonomy. For this reason, there is a need for a security solution capable of withstanding such attacks whilst protecting sensitive information.
 
\subsubsection{Potential Attack Surface of Commercial Mobile Health Applications}

He et al.~\cite{he2014security} analysed several mHealth applications available in Google Play (Android's app store) to contribute to the understanding of security and privacy risk on the Android platform. In the first of three studies described, 160 apps were analysed to find evidence of security threats. From surveying previous literature, seven attack surfaces, shown in Table~\ref{tab:attacksurfaces}, are determined to be in need of protection. This table provides an overview of the problems disclosed by the apps studied, where applications send unencrypted information or use misconfigured internet protocols, store data in third-party server, where data is not assured to be secure, inadvertently log sensitive data to the system or export private app components, making them accessible to other applications.

\begin{table}[t]
	\caption {Description of attack surface (taken from He et al. \cite{he2014security}).}
	\label{tab:attacksurfaces}
	\begin{tabular}{|>{\raggedright}p{2cm}|>{\raggedright\arraybackslash}p{10cm}|}
		\hline
		\textbf{Attack Surface}      & \textbf{Description}                                                                                                                    \\ \hline
		Internet            & Sensitive information is sent over the internet with unsecure protocols (e.g. HTTP), misconfigured HTTPS, etc.                 \\ \hline
		Third Party         & Sensitive information is stored in third party servers                                                                         \\ \hline
		Bluetooth           & Sensitive information collected by Bluetooth-enabled health devices can be sniffed or injected                                 \\ \hline
		Logging             & Sensitive information is put into system logs where it is not secured                                                          \\ \hline
		SD Card Storage     & Sensitive information is stored as unencrypted files on SD card, publicly accessible by any other app                          \\ \hline
		Exported Components &  Android app components, intended to be private, are set as exported, making them accessible by other apps                     \\ \hline
		Side Channel        & Sensitive information can be inferred by a malicious app with side channels, e.g. network package size, sequence, timing, etc. \\ \hline
	\end{tabular}
\end{table}

However, Table~\ref{tab:attacksurfaces} is missing an important attack surface, which is the operating system. Although usually well protected and in constant update to mitigate vulnerabilities found in previous versions, operating systems have an extensive and complex code base, and there are no security guarantees that the system will never be compromised by malware, which can then control system resources and the overlying applications. Resources, such as the framebuffers or touchscreen device, might be explored by a malicious agent in order to disclose data, such as sensitive medical information.

The authors also document that most apps targeted for patients (60\%) are in the Life Management category, which comprises apps nutrition and fitness, followed by apps that manage and synchronize user health information (\ac{PHR} Management), which occupy nearly half (46.88\%) of these applications. These numbers are a good indicator of the data handled by most commercial mHealth apps available, as well as which health apps are more used in the mobile health sector. From these numbers we can infer that a personal health record viewer can serve as a representative use case to demonstrate a trusted output solution.

\subsubsection{Severity of Attacks to Mobile Health Applications}
In the second study by He et al.~\cite{he2014security}, 27 of the top 1080 free apps from the Medical and Health \& Fitness categories on Google Play were analysed in order to assess the most commonly observed vulnerabilities. From this analysis, three attack surfaces are identified as the most important ones: \emph{Internet}, \emph{Third Party Services} and \emph{Logging} (see Table~\ref{tab:attacksurfaces}). Only 7 of the 27 apps use the Internet to effectively send medical information over to remote servers. Some of these apps send unencrypted content, which generally include emails, usernames and passwords. This study also concludes that most of these apps are hosted, and store the recorded data, on third party servers. This is an economical and scalable solution for mobile applications, but storing sensitive health records on third party servers can have serious implications, mostly because users are not capable of assessing whether this data is encrypted in such a way that hosting companies do not have access to it.

In the third study by He et al.~\cite{he2014security}, another 22 apps, which send information over the Internet, are randomly selected from the same top 1080 apps and audited to understand what information is effectively being sent, thus inferring the seriousness of the threats. The conclusion is that, when used as intended, these apps gather, store and transmit a variety of sensitive user data, which includes at least personal profiles, health sensor data, lifestyle data, medical browsing history and third-party app data (e.g. Facebook account information).

The consequences of disclosing or tampering sensitive health data depend on the type, sensitivity and volume of data breached, but it is clear that profiling, medical identity theft and healthcare decision-making errors are all possible. This is why He et al. suggest the use of encryption for communication and storage, and encourage developers to create a set of standard security and privacy guidelines that offer a baseline for protection. However, these measures are not sufficient to protect sensitive data against more complex attacks, such as those which involve a malware compromised operating system. In such a system, where the malicious entity controls system resources, encryption techniques and good developing guidelines might not be enough as the system can bypass these mechanisms and disclose data when it is in its raw displayable form, i.e., unencrypted.\\

Security measures and regulatory laws are implemented for custom healthcare information systems in order to mitigate attacks which may disclose sensitive medical data. However, in the mobile sector, these security measures may not be possible or practical to implement, and regulatory laws, such as \ac{HIPAA}, do not account for the mobile market. For this reason, the research community analysed and categorized mHealth threats, developed a privacy framework and studied commercially available apps in order to achieve a standardized set of rules to mitigate negligent development. But these studies consider the whole operating system as the trusted computing base for mHealth apps, and, because this \ac{TCB} is so complex and unreliable, malware may take control of system resources and consequently leak sensitive data. Ultimately, what the mHealth market needs is a security solution which provides secure primitives that both developers and users desire, such as secure display, without having to rely on a full-featured operating system, inherently with a large \ac{TCB}.

\subsection{General-Purpose Mobile Security Mechanisms}

Like most existing mobile applications, mHealth apps tend to depend on the security services provided by the mobile platform. This section provides an overview of the security mechanisms that have been developed for Android.

Since many security mechanisms have been proposed, we divide them into groups to reflect the different ways in which sensitive information is protected: \emph{(a) access control mechanisms}, which enforce security policies that prevent access to sensitive resources by a given application, \emph{(b) application communication monitoring}, which ensures that sensitive data that was read by a given application can be securely exchanged with co-located applications, \emph{(c) privacy enhancement systems}, which aim at preventing privacy breaches by applications that read sensitive data and need to share it with Internet services, and \emph{(d) trusted execution systems} (TES), which provide restricted environments in which sensitive data can be processed while trusting in a smaller code base than that of a rich OS. Figure~\ref{fig:relwork} maps these four groups to a representation of a possible mobile system.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.50\textwidth]{img/relwork.pdf}
	\caption{Security Mechanisms Map; A-application, R-system resource, TES-Trusted Execution System.}
	\label{fig:relwork}
\end{figure}

\subsubsection{Access Control Mechanisms}
\label{sec:accesscontrol}

% ACCESS CONTROL MECHANISMS
Access control mechanisms implement security models in which subjects (e.g. user, processes, threads, etc.) are constrained by a security policy to perform certain actions on the system, namely access to resources (e.g. files, sensors, etc.), typically called objects.

Android inherits a \ac{DAC} mechanism from its Linux based kernel, but some system resources, such as the IPC Binder mechanism, are accessed via \ac{MAC} policies. In a \ac{DAC} system the data owner is responsible for the data and, as such, determines who can access it. In Android, an application can create and store files in the filesystem, thus becoming the sole owner of such files, and it can allow access to them for any other application. In \ac{MAC}, subjects are much more restricted in determining specific permissions because the restrictions on these resources are defined by a global system policy. In the Android operating system, once a subject attempts to access an object, it triggers a policy evaluation by the kernel, which assesses whether the access is granted. The advantage of this strict system is its robustness and restrictiveness, because subjects cannot override or modify the security policy. In Android, applications must specify in their manifest the permissions they require at runtime, and after the installation neither applications nor users have any control over the access policies.

Because \ac{MAC} is more restrictive, several systems were created over the years to extend \ac{MAC}'s access control model to other Android resources. SEAndroid~\cite{smalley2013security} solves problems related to resources complying with the \ac{DAC} mechanism. The authors ported SELinux~\cite{peter2001integrating} to provide \ac{MAC} at the kernel layer. The kernel was then modified to support a new \ac{MAC} policy (e.g., filesystem, IPC) and a new middleware layer (MMAC) was created to extend \ac{MAC} to Android's Binder IPC. TrustDroid~\cite{bugiel2011practical} extends the \ac{MAC} mechanism to all the platform's resources in order to isolate different domains' sensitive information.

\paragraph{\textbf{Permission Refinement}}

In spite of its robustness, the Android permission mechanism is a very restrictive. At install time, the system displays on screen the list of application-specific permissions that must be accepted or denied by the user. The user is forced into a binary decision, either granting all permissions or quitting the installation. Furthermore, some of these applications may even require more permissions than those effectively needed. This is an inflexible solution, which makes it impossible for users to have full control over the permissions an application effectively requires at runtime. This inflexibility allows an app to use the device's resources without the user's knowledge, possibly with malicious intent.

Over the years, many systems aimed at improving the state of affairs through permission refinement. APEX~\cite{nauman2010apex} modified Android's permission model to allow users to specify the assignment of permissions to each app, both at install and runtime. Permission Tracker~\cite{kern2012permission} allows users to be informed on how permissions are used at runtime and offers the possibility of revoking those permissions. Furthermore, a user can specify which permissions are of interest so they can be notified of every permission access and decide whether to grant or deny that access. These systems improve the original Android permission model, but require manual configuration by the user. % tempo verbal no they
A more useful solution would be to use a context-aware system to handle the permissions at runtime. This way it may be possible to automatically restrict permissions to all applications running along side a security sensitive app, thus isolating this application and avoiding possible leaks by shared resources.

There are several context-aware permission refinement systems developed by the research community. Trusted third parties can use CRePE~\cite{conti2011crepe} to enforce security policies on other devices. For example, an employer may enforce a security policy on the employees' mobile devices when inside the company. Similarly, MOSES~\cite{russello2012moses} enforces domain isolation through the concept of security profiles, allowing it to switch security profiles based on pre-established conditions (e.g., GPS coordinates and time). Additionally, MOSES leverages TaintDroid~\cite{enck2014taintdroid} to prevent apps from one profile to access data belonging to another. Both CRePE and MOSES suffer from a device control issue where a third party defines a policy that cannot be revoked by the user. Moreover, a user has no way to deny the enforcement of a third party policy. 

\paragraph{\textbf{Access Control Hook APIs}}

Most security extensions, such as CRePE~\cite{conti2011crepe} or MOSES~\cite{russello2012moses}, require modifying and adding components to the kernel and middleware layers in order to implement new security models. Some frameworks, such as \ac{ASM}~\cite{heuser2014asm} and \ac{ASF}~\cite{backes2014android}, were built in order to ease this development process. These frameworks allow developers to easily create new security models as ordinary Android applications whilst benefiting from a full callback system, which allow apps to be notified of accesses to resources of interest.

These frameworks comprise a set of hooks distributed along the kernel and middleware layers, which can be registered by a secure application. When a hook is activated it triggers a callback from the Hook API module, which in turn is forwarded to the app for verification. The app then decides if the operation that triggered the hook activation may or may not proceed. The main advantage of these frameworks is the flexibility and freedom given to developers in choosing whatever resources to manage.

\paragraph{\textbf{Memory Instrumentation}}

An alternative approach to implementing access control policies is based on memory instrumentation. Memory instrumentation leverages application code analysis techniques to restrict access from those applications to the corresponding resources. Memory instrumentation can be divided in two groups: \emph{static memory instrumentation} and \emph{dynamic memory instrumentation}. While static memory instrumentation changes pre-compiled bytecode, dynamic instrumentation patches running processes, and for this reason it supports the enforcement of new security models. DeepDroid~\cite{wang2015deepdroid} relies on dynamic memory instrumentation to enforce fine-grained context-aware security policies for enterprise and does this by patching several system services and tracing system calls to resources of interest.

\paragraph{\textbf{Digital Rights Management}} is a specific access control technology which allows data owners to restrict if and how their data can be copied and also how it can be handled once transferred to another device.
% NUNO - Acrescenta uma frase para explicar como é que o DRM é usado hoje, por exemplo para proteger cópia ilegar de conteúdos multimétia, e.g., videos, musica, e ebooks.
The \ac{DRM} ecosystem is composed of the following entities:

\begin{itemize}
	\item[$\bullet$] \emph{User} - human user of the DRM Content;
	\item[$\bullet$] \emph{Content Issuer} - entity that delivers the content;
	\item[$\bullet$] \emph{Rights Issuer} - entity responsible for assigning permissions and constraints to \ac{DRM} content;
	\item[$\bullet$] \emph{Rights Object} - XML document generated by a Rights Issuer expressing the restrictions associated to the content;
	\item[$\bullet$] \emph{\ac{DRM} Agent} - trusted entity responsible for enforcing permissions and constraints upon the \ac{DRM} content.
\end{itemize}

In order to define the format of the content delivered to DRM Agents, as well as the way this content can be transferred from the Content Issuer to the DRM Agent, the \ac{OMA} developed the DRM standard~\cite{drm}. Android provides an extensible DRM framework, called Android DRM Framework~\cite{android_drm}, allowing application developers to enable their apps to manage rights-protected content by complying with one of the supported DRM schemes (mechanisms, enforced by DRM Agents, to handle particular types of files).

To understand how \ac{DRM} could be employed in the context of mHealth, one can suggest the simple example of a \ac{PHR} mobile health application. In this scenario, the healthcare provider (e.g. a hospital) would be the \emph{content issuer}, and it would use a \emph{rights issuer} to assign the restrictions imposed upon the \ac{DRM} content, which in this case would be the personal health record of a patient, when this content is transferred to the patient's device. When using \ac{DRM}, the patient is limited to access the content through a \emph{\ac{DRM} Agent}. Although this solution seems to fit the security properties a critical application requires, once again the whole operating system belongs to the trusted computing base. Therefore, resources shared by different applications such as the framebuffers and display devices may leak sensitive information if the system would become compromised.

\subsubsection{Application Communication Monitoring}

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.95\textwidth]{img/communicationattacks.png}
	\caption{Confused deputy attack (a); Collusion attack (b) - (taken from Duarte \cite{nunoduarte}).}
	\label{fig:communicationattacks}
\end{figure}

Along with access control enforcement, some concerns have been raised about the security of Android's standard \ac{IPC} mechanism, which allows different processes, i.e. applications, to communicate between each other and controls how apps access system components. However, this mechanism can be abused such that applications access unauthorized resources or data. In this section we describe two attacks on Android's IPC mechanism followed by systems developed to mitigate such attacks. The attacks described are called \emph{Confused Deputy Attacks} and \emph{Collusion Attacks} and are represented in Figure~\ref{fig:communicationattacks}.

Confused deputy attacks basically consist of unprivileged applications taking advantage of other applications’ publicly accessible APIs to perform an unauthorized action. If App 2 publicly allows other apps to use the Internet through its API, then the user is unaware that App 1 can use the Internet without explicitly requesting it in its manifest. Collusion attacks consist of an app, which might not have permission to perform an operation, still being able to perform it if there exists another app, belonging to the same developer and installed on the user’s device, with the permission to perform said operation. This happens because Android’s permission system is based on UIDs.

Confused deputy attacks allow applications to use resources without explicitly specifying the necessary permission to do so, and to mitigate such attacks the research community developed Saint~\cite{ongtang2012semantically} and QUIRE~\cite{dietz2011quire}. Saint was created to specify which apps can access the public APIs of another app. QUIRE denies access to an API if in the message exchanged between apps, which contains the full call chain context, the source of the request does not have the necessary permission to access the corresponding data.

Collusion attacks are based on a malicious developer building a legitimate application and persuading the user to install a second app with different permissions. Both apps can collude to leak sensitive information by cooperating with each other. XManDroid~\cite{bugiel2011xmandroid} extends the Android permission model in order to support policies that could constrain the way apps interact with each other. This system prevents data leakage or other types of collusion attacks by developing a graph at runtime with a representation of the apps’ interactions, which is then used to regulate inter-app communication.

Although these systems can be used to avoid promiscuous communication between applications they do not support the development of apps with the goal of displaying sensitive content securely.

\subsubsection{Privacy Enhancement Systems}

The mechanisms reviewed so far cover the security issues involved when an application \emph{1)} reads data from a given resource, or \emph{2)} attempts to share sensitive data with co-located applications. In addition, applications may try to exfiltrate sensitive data to remote untrusted parties which raises privacy concerns. In fact, the biggest concern for privacy-sensitive mobile applications is sensitive data leakage, specially with valuable data such as health records. In this section we describe systems which aim to control the flow of sensitive data in order to assess whether such data leaves the systems as a consequence of a malicious action.

Systems like MockDroid~\cite{beresford2011mockdroid}, TISSA~\cite{zhou2011taming} and IdentiDroid~\cite{shebaro2014identidroid} are extensions to Android's data access control mechanism and prevent untrusted applications from accessing sensitive data by allowing users to manually specify application access rights over the system services, such as geographic location, or provide data shadowing\footnote{Data shadow is the return of empty or incorrect information instead of the intended data.} to return plausible but incorrect results to the requesting app.

Alternative systems use a different approach to solve the sensitive data disclosure problem. Unlike data access control mechanisms, dynamic taint analysis systems, such as TaintDroid~\cite{enck2014taintdroid}, prevent data leakage by tainting data with a specific mark and then evaluate how this data is propagated through the system. If this data attempts to leave, then the user is alerted. This system suffers from limitations such as \emph{(i)} tracking a low number of data sources (mainly sensors), \emph{(ii)} performance overheads not tolerable for most mobile environments, \emph{(iii)} the existence of false positives leading to access control circumvention and \emph{(iv)} the incapacity of analysing sensitive information leakage through covert channels.

Although these systems can be leveraged in order to understand if sensitive data is leaving the system through network sinks, they fall short in assessing whether data is accessed via shared resources such as framebuffers and display devices, meaning that a compromised OS may access such resources and disclose sensitive information.

\subsubsection{Trusted Execution Systems}
\label{sec:tee}

In all previously discussed systems, the mobile applications depend entirely on the integrity and correctness of the operating system. In other words, the trusted computing base includes the full-featured operating system responsible for the apps execution. To reduce the trusted computing base, \emph{trusted execution systems} (see Figure~\ref{fig:relwork}) allow certain (in some cases all) operating system components to be disabled or deemed untrusted and providing a restricted execution environment in which sensitive application code and data can be executed safely.

\paragraph{\textbf{TrUbi}} is a system, developed by Duarte \cite{nunoduarte} and Costa \cite{miguelcosta}, built on top of ASM \cite{heuser2014asm} which allows for flexible system-wide resource restriction. This system may be used to isolate privacy-sensitive apps by killing, freezing or revoking permissions to running applications. With TrUbi it is possible to isolate the execution of a critical application from the remaining apps installed on the system, for example, a simple \ac{PHR} app to display personal health records could be developed with the following premise. When the \ac{PHR} app is running, all the other apps are killed and all the resources blocked. The app could then download the health records from the healthcare provider and show the data to the user. When the user exits the application, their data is encrypted with a key generated from a user password, and only then the resources are released for the other applications. The system was completely isolated during the whole process and the data is stored with encryption (and the key, because it is generated from a user password, is not stored on the system).

Although TrUbi effectively reduces the TCB dynamically by disabling concurrent running processes, it still trusts the operating system's code base which may be compromised by malware. Furthermore, TrUbi has no support for trusted UI meaning that a compromised OS can access sensitive data by disclosing the content of resources such as graphical framebuffers and display devices. The following systems allow for a more significant reduction of the TCB by isolating the execution environment of sensitive code from that of a full-featured OS.

\paragraph{\textbf{External and Internal hardware security modules}} External hardware security modules represent the classic security solution for embedded applications, which consists of offloading trust from the OS into a dedicated piece of hardware commonly named \emph{trusted element} (e.g., a smartcard). Typically, the trusted element is located outside of the main \ac{SoC}. The main advantage of this solution is that it allows for the encapsulation of sensitive assets inside a physical device specially designed for robust security. Internal hardware security modules are, contrary to external modules, included within the \ac{SoC}. These integrated modules are usually one of two forms: the first is a hardware block designed specifically for managing cryptographic operations and key storage, and the second is a general purpose processing engine, which is placed alongside the main processor, that uses custom hardware logic to prevent unauthorized access to sensitive resources. This solution has the advantage of being cheaper and offering a performance improvement over external hardware security modules.

However, the main disadvantage of both external and internal security modules is that they only provide secure processing and storage functions. This means that some operations (e.g., I/O) must rely on software running outside of the security perimeter to provide the desired features. In both of these hardware-based security solution, sensitive information from the trusted element must always go through the rich OS before it can be written to the framebuffer, opening the window for interception by malicious agents. The next systems solve this problem by allowing complete isolation between different execution environments.

\paragraph{\textbf{TrustZone}} is a hardware architecture designed to allow the execution of code in isolation from the rich operating system (see Figure~\ref{fig:trustzone_architecture}). In this architecture, the full-featured operating system runs in the normal world domain, while the trusted code running in the secure world can execute without relying on a complex code base. TrustZone also mitigates performance overheads inherent to software virtualization techniques since the hypervisor mechanism, which manages the trusted and untrusted domains, is implemented natively in hardware.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.80\textwidth]{img/trustzone.pdf}
	\caption{TrustZone's Software Architecture (adapted from \cite{trustzone_whitepaper}).}
	\label{fig:trustzone_architecture}
\end{figure}

TrustZone hardware and software architecture are described in a whitepaper~\cite{trustzone_whitepaper} by ARM. In a TrustZone-enabled system, a physical processor provides two virtual cores, one considered non-secure and the other secure, as well as a robust context switching mechanism known as monitor mode. The NS bit sent on the main system bus identifies which of the virtual cores performed an instruction or data access. Several software architectures can be implemented on the software stack of a TrustZone-enabled processor, but the most powerful one is a dedicated operating system in the secure world, as shown in Figure~\ref{fig:trustzone_architecture}.

This design allows for concurrent execution of multiple secure world apps and services that are completely independent from the normal world environment, thus, even with a compromised normal world, the secure world executes as expected. Moreover, the kernel design can enforce the logical isolation of secure tasks from each other, preventing one secure task from tampering with the memory space of another. These advantages sparked the research community in developing several systems which leverage this technology to implement security features. For this reason, TrustZone will be discussed in depth in Section~\ref{sec:trustzone}.

\subsubsection{Summary}

After describing the state of the art of general-purpose mobile security mechanism, we discuss to what extent existing systems have the potential to provide trusted output paths.

Access control mechanisms focus on restricting access to system resources, which may be useful for critical applications if these can use it to limit the access to shared resources by less sensitive applications running in parallel. But these mechanisms rely on a full-blown operating system, with a large and complex TCB, to ensure this property, which may become compromised by malware and sabotage these security measures. Moreover, these systems do not offer trusted user interfaces as they provide no explicit isolation between the operating system and resources such as display devices and framebuffers. For these reasons, access control mechanisms do not fulfil the needs of this project.

Application communication monitoring focuses on assuring that communication attacks cannot effectively target Android's IPC mechanism, which is the main communication component between applications in the Android platform. Because these systems are not meant to be used for the development of applications, but rather as a protective measure against specific attacks, these mechanisms are not suitable to solve the underlying problem of developing critical applications to securely display sensitive data.

Privacy enhancement systems focus assessing whether sensitive data leaves the system via network sinks. While these systems are useful in controlling the data flow of traditional paths, such as Android's IPC, it falls short of controlling the data flow of unconventional paths, such as framebuffers and display devices, meaning that sensitive data may be intercepted by a malicious OS without the privacy enhancement system knowing it.

Trusted execution systems focus on supporting an isolated environment which comprises a smaller TCB than that of a full-featured OS. This category comprises very different systems, with different purposes and approaches, which we summarize next. TrUbi dynamically reduces the overall system's TCB while a critical application is running, but this is done whilst relying on the OS, which may be compromised.

External and internal hardware security modules offer an isolated hardware-based environment for the execution of secure tasks. But because both external and internal modules provide only secure processing and storage functions, the data it protects must eventually be used outside the isolated environment, for instance for display purposes. This means that these systems still rely on the untrusted OS for functionality such as trusted UI, which we want to be supported by the secure environment.

Lastly, TrustZone also supports isolated environments running along side one another by leveraging special purpose hardware to isolate both domains, which mitigates the performance overhead of software based isolation. Additionally, TrustZone also supports trusted user interfaces by controlling the necessary peripherals. For this reason, TrustZone will be discussed in depth in the next section, as it supports all the features necessary to implement \emph{ViewZone}.

% TRUSTZONE
\subsection{TrustZone-based Mobile Security Systems}
\label{sec:trustzone}

To improve security, mobile device manufacturers have been designing hardware architectures enhanced with \emph{trusted hardware}. Among the available security architectures there is ARM's TrustZone technology, a trusted hardware which allows the development of a diverse set of security systems and services, such as Samsung KNOX~\cite{knox_whitepaper} and DroidVault~\cite{li2014droidvault}. TrustZone is becoming popular as it supports code to be executed isolated from a full-featured operating system such as Android. This allows for a reduced trusted computing base on the critical applications running in the isolated environment.

One of the most important uses of TrustZone is building Trusted Execution Environments (TEE), which are compact systems running in the secure world to provide an isolated environment for critical applications. Since its formal standardization by the OMTP in 2007, several \ac{TEE} software stack architectures have been implemented. This standard comprises a set of security requirements on functionality a TEE should support. The GlobalPlatform~\cite{global} organization went a step further by defining standard APIs: on the one hand, the TEE internal APIs that a trusted application can rely on, and on the other hand, the communication interfaces that rich OS software can use to interact with its trusted applications.

Table~\ref{tab:trustzonesystemscomparison} categorizes the existing systems in two main dimensions. When surveying the literature, TrustZone-based systems can be divided into two separate groups depending on whether they support general or specific application code hosting: Trusted Kernels, and Trusted Services. Trusted Kernels, which comprise the TEEs, allow the execution of generic code in the secure world environment, whilst a Trusted Service implements a special-purpose application in the secure domain and can run directly on bare metal (e.g., a secure key store, an authentication service, etc.). Orthogonally, one can classify both groups with regards to support for trusted user interface (UI). A TrustZone-based system features Trusted UI if it allows secure world components to directly access the mobile interface without interference from the rich OS, thus minimizing the risk of, for instance, password logging. Since \emph{ViewZone} aims to offer a specific functionality for enabling secure display of application data, our system can be considered as a Trusted Service with trusted UI, which fits the second quadrant of Table~\ref{tab:trustzonesystemscomparison}.

The remainder of this section describes in more detail the existing Trust-Zone enabled systems according to all four categories: \emph{(i)} Trusted Kernels with Untrusted UI, \emph{(ii)} Trusted Services with Untrusted UI, \emph{(iii)} Trusted Kernels with Trusted UI and \emph{(iv)} Trusted Services with Trusted UI.

\begin{table}[t!]
	\caption{TrustZone-based system categorization.}
	\label{tab:trustzonesystemscomparison}
	\centering
	%\resizebox{\textwidth}{!}{%
	\begin{tabular}{ c|c|c| }
		\multicolumn{1}{c}{} 				& \multicolumn{1}{c}{Untrusted UI} 	& \multicolumn{1}{c}{Trusted UI} \\ \cline{2-3}
		\multirow{6}{*}{T. Services} 	&									& \\
		& Android Key Store					& TrustOTP \\
		& DroidVault 						& TrustDump \\
		& Brasser et al.					& AdAttester \\
		& 									& TrustUI \\
		&									& \\
		\cline{2-3}
		\multirow{7}{*}{T. Kernels}	&									& \\
		& TLK								& Genode \\
		& OP-TEE 							& T6 \\
		& Andix OS							& TrustICE \\
		& Nokia ObC							& SierraTEE \\
		& TLR 								& Samsung KNOX \\
		&									& \\
		\cline{2-3}
	\end{tabular}
	%}
\end{table}

\subsubsection{Trusted Kernels with Untrusted UI}

Trusted Kernels have the goal of executing generic code in its isolated environment, and most of theses kernels have similar architectures (similar to the one described in section~\ref{sec:tee}). This architecture is generally composed of a small trusted kernel running in the secure world of TrustZone-enabled processors, a normal world user space client API and a kernel TEE device driver, used to communicate between worlds.

OP-TEE~\cite{op_tee}, TLK~\cite{tlk}, TLR~\cite{santos2011trusted} and AndixOS~\cite{fitzekandix} are \ac{TEE} implementations which share this general architecture. On-board Credentials (ObC)~\cite{kostiainen2012board} is another \ac{TEE} system, originally developed for Nokia mobile devices using the TI M-Shield technology and later ported to ARM's TrustZone, which supports the development of secure credential and authentication mechanisms. Although these systems use TrustZone hardware based isolation to ensure that applications running inside the secure world are not modified by a compromised rich OS, they were implemented with the goal of reducing the \ac{TCB} in order to ensure a less vulnerable system, and for this reason there are some limitations regarding the features they can support.

A reduced \ac{TCB} means that most features of standard mobile operating systems are not supported. For instance, in both TLR and OP-TEE, as well as AndixOS, the secure world kernel lacks drivers for peripherals such as the touchscreen or code to control the framebuffer, thus it is not capable of supporting trusted UI. For this reason, these systems do not allow developers to easily build trusted applications for sensitive data display. Instead, these sytems support an RPC-like mechanism for in-between-world communication, secure persistent storage and basic cryptographic systems allowing for the development of simple trusted services.

\subsubsection{Trusted Services with Untrusted UI}

As opposed to Trusted Kernels, which enable the execution of general-purpose application code on the secure world, Trusted Services are designed to implement specific applications in the secure world natively. Some trusted services, such as DroidVault~\cite{li2014droidvault} and Restricted Spaces~\cite{brasserregulating}, use custom trusted kernels to fully control the underlying hardware and execution environment, whilst designing specific security solutions which may not be supported by generic trusted kernels.

A system by Brasser et al.~\cite{brasserregulating}, which will be referred to as Restricted Spaces for the remainder of this section, allows for third parties (hosts) to regulate how users (guests) use their devices (e.g., manage device resources), while in a specific space. This system comprises of authentication and communication mechanisms between the guest's secure world and the host's, and remote memory operations, which allow for configuration changes such as uninstall peripheral drivers, either by pointing their interfaces to NULL, or by pointing them to dummy drivers that just return error codes. With this, Remote Spaces is capable of securely refine device permissions using a context-aware approach.

DroidVault~\cite{li2014droidvault} introduces the notion of data vault, which is an isolated data protection manager running in the trusted domain for secure file management for Android mobile devices. To achieve this, DroidVault adopts the memory manager and interrupt handler from Open Virtualization's SierraTEE~\cite{sierra_tee} and is implemented with a data protection manager, encryption library and a port of a lightweight SSL/TLS library called PolarSSL~\cite{polar}. Much like Restricted Spaces, DroidVault supports world switching through software interrupts, secure boot and even inter-world communication. With this Trusted Service a user can download a sensitive file from an authority and securely store it on the device. The sensitive file is encrypted and signed by the data protection manager before it is stored in the untrusted Android OS, in order to save space in the limited storage capacity available at the secure world domain.

Android Key Store~\cite{aks} is another security service in Android. This service allows for cryptographic keys to be stored in a container (keystore), so its extraction from the device becomes difficult and so they can be used for common cryptographic operations. The encryption and decryption of the container is handled by the keystore service, which in turn links with a hardware abstraction layer module called ``keymaster''. The Android Open Source Project (AOSP) provides a sofware implementation of this module called ``softkeymaster'', but device vendors can offer support for hardware based protected storage when available by using TrustZone.

% RETIRAR A PARTE DO DROIDVAULT NESTE ULTIMA FRASE?
The main drawback of the Trusted Services just mentioned is that they do not fulfil the goals of this project as they do not support necessary features such as secure display. On the other hand, DroidVault takes an interesting approach to secure storage support for Trusted Services.

\subsubsection{Trusted Kernels with Trusted UI}

In this section we describe Trusted Kernels, which allow the execution of generic code in the secure world environment, with support for trusted UI. As referenced in Section~\ref{sec:trustzone}, GlobalPlatform defined standard APIs for the communication between the rich OS running in the normal world and the secure OS. However, this organization also defined device specifications that TEEs must comply in order to be certified. Included in these device specifications there is a trusted UI clause, meaning that every TEE which complies with GlobalPlatform's device specifications must support trusted UI. 

SierraTEE~\cite{sierra_tee}, T6~\cite{t6_tee} and Open-TEE~\cite{mcgillion2015open} comply with the GlobalPlatform standard, and for this reason allow the development of trusted applications with secure user interfaces. Open-TEE's trusted UI feature is being developed by the community as it was not originally supported. The Genode OS Framework~\cite{genode} is a tool kit for building highly secure special-purpose operating systems to be executed in TrustZone-enabled processors. Genode implements a framebuffer and input drivers to be used by the secure kernel, thus trusted applications running on top of Genode-based TEEs can offer trusted user interfaces.

Samsung KNOX~\cite{knox_whitepaper} is a defense-grade mobile security platform which provides strong guarantees for the protection of enterprise data. Security is achieved through several layers of data protections which include secure boot, TrustZone-based integrity measurement architecture (TIMA) and Security Enhancements for Android (SEAndroid~\cite{smalley2013security}, which was already discussed in Section~\ref{sec:accesscontrol}). Samsung KNOX offers a product called KNOX Workspace, which is a container designed to separate, isolate, encrypt, and protect work data from attackers. This enterprise-ready solution provides management tools and utilities to meet security needs of enterprises large and small. Workspace provides this separate secure environment within the mobile device, complete with its own home screen, launcher, applications, and widgets.

Unlike the solutions previously described, such as Genode OS and Samsung KNOX, which provide isolated computing environments by allowing code to be executed in the secure world, generally in the form of trusted applications, TrustICE~\cite{sun2015trustice} aims at creating Isolated Computing Environments (ICEs) in the normal world domain rather than in the secure world. For this reason, TrustICE's architecture is slightly different from those described before.

Figure~\ref{fig:trustICE_architecture} compares TrustICE's architecture with that of a traditional TrustZone TEE, where trusted applications run inside the secure world domain. TrustICE works by implementing a trusted domain controler (TDC) in the secure world, which is responsible for suspending the execution of the rich OS as well as other ICE's in the system when another ICE is running, thus supporting CPU isolation for running ICE's. For memory isolation a watermarking mechanism is implemented so the rich OS cannot access secure code running in the normal world memory. In order to isolate I/O devices the secure world blocks all unnecessary external interrupts from arriving at the TDC, thus protecting the TDC from being interrupted by malicious devices, the exception being a minimal set of required interrupts to allow trusted UI.

Because these systems support secure display they are adequate for the development of trusted applications which require sensitive information to be displayed to the user. However, developing such applications is complex because the application development environments are cumbersome and error-prone.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.80\textwidth]{img/trustICE.pdf}
	\caption{Architecture comparison between traditional TrustZone's software stack and TrustICE (adapted from~\cite{sun2015trustice}).}
	\label{fig:trustICE_architecture}
\end{figure}

\subsubsection{Trusted Services with Trusted UI}

Besides Trusted Kernels, some Trusted Services offer secure display to applications implemented in the secure domain. The technical challenge is implementing drivers in the secure world without greatly increasing the TCB, and this is solved by implementing very small special-purpose display drivers. Several Trusted Services with trusted UI support have been proposed in the literature.

TrustOTP~\cite{sun2015trustotp} is a One-Time-Password (OTP) system, secured by hardware, where the OTP is generated based on Time and a Counter secured by TrustZone's memory management. Most trusted applications described before require inter-world communication to trigger the world-switching mechanism. This system leverages hardware interrupts to trigger the world-switch. This mitigates denial-of-service attacks by a malicious rich OS which may control the inter-world communication mechanism and intercept the calls (software interrupts) required to trigger the world-switch. 

Providing a different service, TrustDump~\cite{sun2015reliable} is a secure memory acquisition tool and offloads the memory through micro-USB. Similarly to TrustOTP, this system relies on hardware interrupts to trigger world-switches. This solution may be implemented by systems which require no inter-world communication, but for systems which need to offer seamless integration with the normal world this approach may have to be leveraged with other development strategies. Both of these systems support trusted UI by implementing secure display and input drivers and display controllers to manage the secure framebuffers.

Instead of implementing the required drivers to support trusted UI, some systems designed mechanisms to allow the reuse of untrusted drivers, implemented in the rich OS, by the secure world domain. TrustUI~\cite{li2014building} excludes the device drivers for input, display and network from the secure world, and instead reuses the existing drivers from the normal world, thus achieving a much smaller TCB than previously described systems. Because we are only interested in secure display, the following explanation discards the network delegation mode and input mechanism. To achieve trusted UI, device drivers are split into two parts: a backend running in the normal world domain and a frontend running in the secure world. Both parts correspond to proxy modules running in both worlds, which communicate via shared memory. Whenever secure display is necessary, the frontend asks for a framebuffer from the backend driver and sets that memory region as secure only, thus isolating the framebuffer from rich OS manipulation. 

Because this mechanism can still be victim of framebuffer overlay attacks, where a malicious backend driver gives a false framebuffer to the secure world, the system randomizes the background and foreground colours used in the display and uses two LEDs, controlled by the secure world, to show these same colours. A user can visually check if the colours shown in the secure LEDs match those of the display. If they match then the user is assured that the display shown is being controlled by the secure world.

These systems support secure display, as such, they do not disclose sensitive data. However, TrustOTP and TrustDump do not offer a fully integrated environment with the Android running in the normal domain. TrustUI, on the other hand, fully integrates its environment with that of the Android operating system. Furthermore, TrustUI describes a novel mechanism for the reuse of untrusted driver in the normal world without compromising security, which significantly reduces the secure system's TCB. The main disadvantage of TrustUI is that, similarly to TrustOTP and TrustDump, does not support the development of generic display applications. Besides, TrustUI is not immune to denial-of-service attacks by a malicious operating system running in the normal world, which may compromise the execution of the secure system.\\

From the systems described in this section we learned the underlying strategies for developing security systems using TrustZone. For this reason, the following section describes the architecture of \emph{ViewZone}, a solution for securing the output of Android applications using TrustZone.