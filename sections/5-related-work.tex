%!TEX root = ../report.tex

% 
% Related work
% 
% (~17pgs)
\section{Related Work}

% começar por dizer como é que está organizada esta secção do trabalho e resumir de uma forma muito geral o que se fala em cada subsecção

This section describes the related work and characterizes the main contributions from the research community and how these contributions helped in the development of this project. This section is organized in three main parts: mobile health security, general-purpose mobile security mechanisms and TrustZone-based systems.

%FIRST
The first part focuses on describing the attack surfaces of mHealth apps, the most common threats and their seriousness. It also shows a few publicly available insecure mHealth apps as well as some compliance recommendations app developers should follow to avoid unnecessary security risks when handling sensitive health information.
%SECOND
The second part of this section describes the state-of-the-art of general-purpose mobile security mechanisms with a particular focus on the Android Operating System.
%THIRD
The third part of the related work describes systems developed using TrustZone, a hardware technology available in most modern ARM processors which support the execution of two isolated worlds, a hardware-protected secure world and a normal world, and how these contributions may be helpful in achieving the goals of this project. 

\subsection{Studies in Mobile Health Security}
\label{sec:mhealth}

% A REPETIR UM BOCADO O QUE JÁ FOI DITO NA INTRO...
As discussed above, mobile devices are increasing in number at astonishing rates, and with this growth the mobile market becomes cheap and accessible. This motivates the shift from mainframe systems, located in the facilities of healthcare providers, to apps on mobile devices as well as storage in shared cloud services. This accessibility also motivates the private sector in building more mobile healthcare applications to support both patients and professionals. Thus, the mobile health sector is becoming a competitive market and one which is increasingly handling more sensitive data.

The following subsections describe work done in assessing the current security state of commercial mobile health applications. The first subsection describes a threat taxonomy for mHealth applications by Kotz, David \cite{kotz2011threat}. The second and third subsections describe work done by He, Dongjing, et al. \cite{he2014security} through the analysis of three studies which answer the following questions: what are the potential attack surfaces, how widespread and how serious are the security threats to mobile health applications.

\subsubsection{Threat Taxonomy for Mobile Health Applications}

Kotz, David \cite{kotz2011threat} defines a threat taxonomy for mHealth and categorizes threats in three main categories: \emph{Identity Threats}, \emph{Access Threats} and \emph{Disclosure Threats}.

\paragraph{Identity threats} are described as a mis-use of patient identities and include scenarios where a patient may lose (or share) their identity credentials, allowing malicious agents to access their respective \ac{PHR}. \emph{Insiders} (authorized \ac{PHR} users, staff of the \ac{PHR} organization or staff of other mHealth support systems) may also use patient identities for medical fraud or for medical identity theft, and \emph{outsiders} may be able to observe patient identity or location from communications.

\paragraph{Access threats} are described as unauthorized access to \ac{PHR} and include scenarios where the patient, which controls the data, may allow broader-than-intended access or disclosure of information, \emph{insiders} who may snoop or modify patient data with malicious intent, and even \emph{outsiders} which, by breaking into patient records, may leak or modify this data.

\paragraph{Disclosure threats} include scenarios where an adversary captures network packets in order to obtain sensitive health data. This problem can be mitigated by using strong encryption methods, but even if the network traffic is encrypted it is possible to analyse the traffic to determine its characteristics \cite{wright2006inferring}. The adversary may also use physical-layer, or link-layer fingerprinting, methods to identify the device type and, because the wireless medium is open, an active adversary may inject frames or may selectively interfere (cause collisions) with wireless frames.\\ %These methods may enable the adversary to create a man-in-the-middle situation, to use link-layer fingerprinting methods, or to compromise the devices in a way that divulges their secrets.

This work by Kotz, David \cite{kotz2011threat} helped in understanding what threats are inherent to mHealth systems and their development. An explicit set of rules for developing privacy-sensitive health applications was still needed to ease the development process. Avancha, Baxi and Kotz \cite{avancha2012privacy} filled in the gap by surveying the literature, developing a privacy framework for mHealth and discussing the technologies that could support privacy-sensitive mHealth systems. This survey considers essential accounting for privacy in the design and implementation of any mHealth system, given the sensitivity of the data collected. A developer should use the list of privacy properties provided by this article as a check-list to be considered in any design. It is also mentioned that privacy challenges identified by this article need to be addressed with urgency, because mHealth devices and systems are being deployed now, and retrofitting privacy protections is far more difficult than building them in from the start.

% In this paper, three studies were made to answer the questions: what are the potential attack surfaces, how widespread and how serious is the threat.
 
\subsubsection{Potential Attack Surface of Commercial Mobile Health Applications}

He, Dongjing, et al. \cite{he2014security} analyse several mHealth applications available in Android's app store to contribute to the understanding of security and privacy risk on the Android platform. In the first of three studies described, 160 apps were analysed to find evidence of security threats. From surveying previous literature, seven attack surfaces, shown in Table~\ref{tab:attacksurfaces}, are determined to be in need of protection.
%The authors also document that the 160 apps studied target two different audiences: 129 (81.65\%) are for patients, 32 (20.25\%) are for healthcare professionals and the remaining 3 (1.90\%) are targeted for both.
The authors also document that most apps targeted for patients (60\%) are in the Life Management category followed by apps that manage and synchronize user health information (\ac{PHR} Management), which occupy nearly half (46.88\%) of these apps. These numbers are a good indicator of what data is handled by most commercial mHealth apps available and motivate the choice made to build a \ac{PHR} Management app as demo app for TrubiZone.

\begin{table}[t]
	\caption {Description of attack surface (taken from He et al. \cite{he2014security})}
	\label{tab:attacksurfaces}
	\begin{tabular}{|>{\raggedright}p{2cm}|>{\raggedright\arraybackslash}p{10cm}|}
		\hline
		\textbf{Attack Surface}      & \textbf{Description}                                                                                                                    \\ \hline
		Internet            & Sensitive information is sent over the internet with unsecure protocols (e.g. HTTP), misconfigured HTTPS, etc.                 \\ \hline
		Third Party         & Sensitive information is stored in third party servers                                                                         \\ \hline
		Bluetooth           & Sensitive information collected by Bluetooth-enabled health devices can be sniffed or injected                                 \\ \hline
		Logging             & Sensitive information is put into system logs where it is not secured                                                          \\ \hline
		SD Card Storage     & Sensitive information is stored as unencrypted files on SD card, publicly accessible by any other app                          \\ \hline
		Exported Components &  Android app components, intended to be private, are set as exported, making them accessible by other apps                     \\ \hline
		Side Channel        & Sensitive information can be inferred by a malicious app with side channels, e.g. network package size, sequence, timing, etc. \\ \hline
	\end{tabular}
\end{table}

A few examples of vulnerable applications are also revealed during this study. Regarding unencrypted information sent over the Internet, Doctor Online~\footnote{https://play.google.com/store/apps/details?id=com.airpersons.airpersonsmobilehealth} (patients can talk to doctors online) and Recipes by Ingredients~\footnote{https://play.google.com/store/apps/details?id=com.abMobile.recipebyingredient} send unencrypted sensitive information, including the user's email and password, in clear text. Regarding logging, the study pinpoints CVS/pharmacy~\footnote{https://play.google.com/store/apps/details?id=com.cvs.launchers.cvs}, which logs the prescription refill details from user inputs, including name, email address and store number, and also logs user login credentials in a debug log message. A malicious party can use this information to access prescription history, which could support medical identity theft. Finally, this first study concludes with the example of sleep monitoring apps, such as SnoreClock~\footnote{https://play.google.com/store/apps/details?id=de.ralphsapps.snorecontrol} and Sleep Talk Recorder~\footnote{https://play.google.com/store/apps/details?id=com.madinsweden.sleeptalk}, which store user sleep records as unencrypted audio files on external storage. With read permission for the SD card, as well as internet permission, a malicious app can read a user's sleep recordings and even send them to remote servers.

\subsubsection{Severity of Attacks to Mobile Health Applications}
In the second study, 27 of the top 1080 free apps from the Medical and Health \& Fitness categories on Google Play were analysed according to their vulnerabilities. From this analysis, three attack surfaces are identified as the most important ones: \emph{Internet}, \emph{Third Party Services} and \emph{Logging}. Only 7 of these 27 apps use the Internet to effectively send medical information over to remote servers. It is important to understand if the information sent over the Internet is protected. To achieve this, the authors captured network traffic and concluded that only 57.1\% (4/7) of these apps use encrypted communication and the remaining 42.9\% (3/7) send unencrypted sensitive health information. Among the unencrypted contents sent by these 3 apps are emails, usernames and passwords. This study also concludes that 85.7\% (6/7) of these apps are hosted, and store the recorded data, on third party servers. This is an economical and scalable solution for mobile applications, but storing sensitive health records on third party servers can have serious implications, mostly due to app users not being aware that their data is being stored on third party servers and because these users are incapable of telling whether this data is encrypted in such a way that hosting companies do not have access to it.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.85\textwidth]{img/sensitivedistribution.jpg}
	\caption{Sensitive information distribution for study 3 (taken from  He et al. \cite{he2014security})}
	\label{fig:sensitivedistribution}
\end{figure}

Some health apps use Bluetooth devices to collect personal health information such as heart rate, respiration, pulse oximetry, electrocardiogram (ECG), blood pressure, body weight, body temperature, quality of sleep and exercise activities. Naveed et al.~\cite{naveed2014inside} show how a malicious app can stealthily collect user data from an Android device or spoof it and inject fake data into the original device's app, in what is called an \ac{DMB} attack. One of the 27 apps analysed in this study connects to external health sensors and uses default PIN code 0000, which makes it vulnerable to the \ac{DMB} attack.

Along with the logging, external storage, exported components and other problems discussed above which represent explicit channels used for attacks, side channels can be exploited by a malicious party to infer sensitive information from apps, even when they are well-designed and implemented. This study mentions an example by Zhou et al.~\cite{zhou2013identity} where a correlation between network payload size and the disease condition a user selects on WebMD mobile~\footnote{https://play.google.com/store/apps/details?id=com.webmd.android} exists. Network payload size is publicly accessible in Android, which represents a problem when such correlations can be made. Zhou et al.~\cite{zhou2013identity} mitigate the problem by modifying the Android kernel to enforce limitations on accessing Android's public resources. 

In the third study, another 22 apps, which send information over the Internet, are randomly selected from the same top 1080 apps and audited to understand what information is effectively being sent over the Internet, thus inferring the seriousness of the threats. The conclusion is that, when used as intended, these apps gather, store and transmit a variety of sensitive user data, which includes at least personal profiles, health sensor data, lifestyle data, medical browsing history and third-party app data (e.g. Facebook account information). Figure~\ref{fig:sensitivedistribution} shows the distribution of sensitive data in those 22 apps. The consequences of data breaches, information disclosure or tempering with sensitive health data depend on the type, sensitivity and volume of data breached, but it is clear that profiling, medical identity theft and healthcare decision-making errors are all possible. This is why the authors suggest the use of encryption for communication and storage, and encourage developers to create a set of standard security and privacy guidelines that offer a baseline for protection.\\

The work by He, Dongjing, et al.~\cite{he2014security} helped in understanding what are the most common attack surfaces when considering mHealth applications on Android and it also helped assessing the security risks inherent to applications handling privacy-sensitive information. This paper generally describes the state-of-the-art of security in commercial mobile health apps and pinpoints what should be fixed in order to build better and more secure applications for the healthcare industry.
% REVER A FRASE QUE SE SEGUE COM O PROF
It is clear that developers focus much more on building feature-full apps rather than secure applications and this is why it is important to build a framework which allows developers to completely focus on the features they want to provide without having to focus heavily on security. 

\subsection{General-Purpose Mobile Security Mechanisms}

This section describes the security mechanisms available for the Android platform, either native or as security extensions, and how these mechanisms can be used to solve some of the problems covered in the previous section. The security mechanisms addressed are divided in four groups: \emph{(a)} access control mechanisms, \emph{(b)} application communication monitoring, \emph{(c)} privacy enhancement systems and \emph{(d)} trusted execution environment. Figure~\ref{fig:relwork} maps these four groups to a representation of a possible mobile system.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.65\textwidth]{img/relwork.pdf}
	\caption{Security Mechanisms Map; A-application, R-system resource}
	\label{fig:relwork}
\end{figure}

\subsubsection{Access Control Mechanisms}

This subsection describes mechanisms and implementations of systems responsible for limiting applications' access to system resources and sensitive data, hence access control mechanisms.

% TENTAR RESUMIR ISTO MAIS UM BOCADINHO?
\paragraph{\textbf{Access control mechanisms}} are a security model in which subjects (e.g. user, processes, threads, etc.) can perform actions on the system, namely on resources (e.g. files, sensors, etc.), typically called objects. Android follows a type of access control referenced as \ac{DAC}, heritage from it's Linux based kernel. In a \ac{DAC} system the data owner is responsible for this data and thus determines who can access it. %In a Linux system, one can imagine a system administrator creating several files and allowing access to these files, according to certain permissions. In this example, a subject with the specified permissions may access the file like its owner intended.
In Android, an application can create and store files in the filesystem, thus becoming the sole owner of these files, it can allow access to these files to any other application.

Although Android inherits the \ac{DAC} from its Linux ancestry, most other resources in Android follow \ac{MAC} policies. In \ac{MAC}, subjects are much more restricted in determining who has access to their resources. An example of this are physical security levels: confidential, secret and top secret. These labels are the only concept available to define the level of clearance of subjects or to classify data. When a subject attempts to access a classified piece of data, a verification is done to assess if this subject's security level matches (or is above) that of the classified piece of data. Similarly, in Android once a subject attempts to access an object, it triggers a policy evaluation by the kernel, which assesses whether the access may be granted. The advantage of this strict system is its robustness, because subjects cannot override or modify the security policy. In Android, applications must specify in their manifest the permissions they require at runtime, and after the installation neither applications nor users have any control over the access policies.

Because \ac{MAC} is robust, several systems were created over the years to extend \ac{MAC}'s access control model to other Android resources. SEAndroid \cite{smalley2013security} solves problems related to resources complying with the \ac{DAC} mechanism. The authors ported SELinux \cite{peter2001integrating} to provide \ac{MAC} at the kernel layer. The kernel was then modified to support a new \ac{MAC} policy (e.g., filesystem, IPC) and a new middleware layer (MMAC) was created to extend \ac{MAC} to Android's Binder IPC. TrustDroid \cite{bugiel2011practical} extends the \ac{MAC} mechanism to all the platform's resources in order to isolate different domains' sensitive information.

\paragraph{\textbf{Permission Refinement}} %ISTO TEM QUE SER RESUMIDO MAIS UM POUCO

The Android permission mechanism is a very restrict system. At install time, a list of permissions an application specifies in its manifest file is shown to the user, which is forced into a binary decision, either granting all permissions or quitting the installation. This is an inflexible solution, which makes it impossible for users to have full control of the permissions an application is effectively using at runtime. This inflexibility allows apps to use the device's resources whenever the app wishes without the user's knowledge, possibly with malicious intent. 

Over the years, many systems solved some of the problems inherent to permission refinement. APEX \cite{nauman2010apex} modified Android's permission model to allow users to specify the assignment of permissions to each app, both at install and runtime. Permission Tracker \cite{kern2012permission} allows users to be informed on how the permissions are used at runtime and offers the possibility of revoking these permissions. Furthermore, a user can specify which permissions are of interest so they can be notified of every permission access and decide whether to grant or deny that access. These systems improve upon the original Android permission model, but require manual configuration by the user. A more useful solution would be to use a context-aware system to handle the permissions at runtime. This way it may be possible to, without manual configuration, restrict permissions to all applications running along side a security sensitive app, thus isolating this application and avoiding possible leaks by shared resources.

Several context-aware permission refinement systems exist. Trusted third parties can use CRePE \cite{conti2011crepe} to enforce security policies on another devices whilst, for example, the employees' mobile devices are inside the company, but have no privileges otherwise. Similarly, MOSES \cite{russello2012moses} enforces domain isolation through the concept of security profiles. MOSES can switch security profiles based on pre-established conditions (e.g., GPS coordinates and time).
%When switching from a personal (less restrictive) profile to a professional (more restrictive) one, MOSES terminates and prevents the execution of applications not allowed to run in the new enforced profile.
Additionally, MOSES leverages TaintDroid \cite{enck2014taintdroid} to prevent apps from one profile to access data belonging to another. Both CRePE and MOSES suffer from a device control issue where a third party defines a policy that cannot be revoked by the user. Moreover, a user has no way to deny the enforcement of a third party policy. 

\paragraph{\textbf{Access Control Hook APIs}}

A trend from previous work on mobile security is clearly noticeable: most security extensions require modifying and adding components to the kernel and middleware layers in order to implement new security models. Some frameworks have been built to ease the development process by allowing developers to easily create security models as ordinary apps whilst benefiting from a full callback system capable of notifying the security enforcement applications of accesses and requests to some of the apps' resources of interest.

These frameworks comprise a set of hooks distributed among the kernel and middleware layers, which can be registered by a secure application. When a hook is activated it triggers a callback from the Hook API module, which in turn is forwarded to the app for verification. The app then decides if the operation that triggered the activation of the hook may or may not proceed. The main advantage of frameworks such as \ac{ASM} \cite{heuser2014asm} and \ac{ASF} \cite{backes2014android} is the flexibility and freedom given to developers in choosing whatever resources to manage.

\paragraph{\textbf{Memory Instrumentation}}
Memory instrumentation can be divided in two groups: static memory instrumentation and dynamic memory instrumentation. While static memory instrumentation changes already compiled bytecode, dynamic instrumentation patches running processes. Dynamic memory instrumentation is an interesting mechanism as it supports the enforcement of new security models. DeepDroid \cite{wang2015deepdroid} relies on dynamic memory instrumentation to enforce fine-grained context-aware security policies for enterprise. This is done by patching several system services and tracing system calls.

\paragraph{\textbf{Digital Rights Management}} is a specific access control technology which allows data owners to restrict if and how their data is copied and also how it is handled once transferred to another device. The \ac{DRM} ecosystem is composed of the following entities:

% estruturar melhor esta lista
\begin{itemize}
	\item \emph{User} - human user of the DRM Content
	\item \emph{Content Issuer} - entity that delivers the content
	\item \emph{Rights Issuer} - entity responsible for assigning permissions and constraints to \ac{DRM} content
	\item \emph{Rights Object} - XML document generated by a Rights Issuer expressing the restrictions associated to the content.
	\item \emph{\ac{DRM} Agent} - trusted entity responsible for enforcing permissions and constraints upon the \ac{DRM} content
\end{itemize}

To understand how \ac{DRM} works in the context of mHealth one can suggest a simple example of a \ac{PHR} mobile health application. In this scenario, the healthcare provider (e.g. a hospital) would be the \emph{content issuer}, and it would use a \emph{rights issuer} to assign the restrictions imposed upon the \ac{DRM} content, which in this case would be the personal health record of a patient, when this content is transferred to the patient's device. When using \ac{DRM}, the patient is limited to access the content through a \emph{\ac{DRM} Agent}.

The \ac{OMA} developed a DRM standard \cite{drm} which defines the format of the content delivered to DRM Agents, as well as the way this content can be transferred from the Content Issuer to the DRM Agent. Android provides an extensible DRM framework, called Android DRM Framework \footnote{http://developer.android.com/reference/android/drm/package-summary.html}, allowing application developers to enable their apps to manage rights-protected content by complying with one of the supported DRM schemes (specific mechanisms, enforced by DRM Agents, to handle particular types of files).

\subsubsection{Application Communication Monitoring}

Another problematic mechanism in Android is the way applications interact with each other. Some problems were already described in section \ref{sec:mhealth} regarding vulnerable mobile health applications, which fall into this category. Two attacks will be described in this section, followed by systems developed to mitigate such attacks on Android. The attacks described are called \emph{Confused Deputy Attacks} and \emph{Collusion Attacks} and are represented in Figure \ref{fig:communicationattacks}. Confused deputy attacks basically consist of unprivileged applications taking advantage of other applications’ publicly accessible APIs to perform malicious actions. Collusion attacks consist of an app, which might not have permission to perform an operation, still being able to perform it if there exists another app, belonging to the same developer, installed on the user’s device with the permission to perform said operation. This happens because Android’s permission system is based on UIDs.

% será que é mesmo necessário?
% REVER
Confused deputy attacks allow applications to use resources without explicitly specifying the necessary permission to do so. %A simple example is an app that exposes a service on its API allowing another app to receive photos directly from the device's camera. The second app, which did not specify the camera permission, can access this sensor without the user's knowledge. This problem generally happens because of poor or negligence application development.
A system  called Saint \cite{ongtang2012semantically} was created to specify which apps can access the public APIs of another app. Other systems control this communication by extending Android’s Binder \ac{IPC} mechanism, which is the main form of application inter-communication in Android. QUIRE \cite{dietz2011quire} denies access to an API if in the message exchanged between apps, which contains the full call chain context, the source of the request does not have the necessary permission to access the corresponding data.

% será que é mesmo necessário?
% REVER
Collusion attacks are based on a malicious developer building a legitimate application and persuading the user to install a second app with different permissions. Both apps can collude to leak sensitive information by cooperating with each other. XManDroid \cite{bugiel2011xmandroid} extends the Android permission model in order to support policies that could constrain the way apps interact with each other. This system prevents data leakage or other types of collusion attacks by developing a graph at runtime with a representation of the apps’ interactions, which is then used to regulate app inter-communication.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.95\textwidth]{img/communicationattacks.png}
	\caption{Confused deputy attack (a); Collusion attack (b) - (taken from Duarte \cite{nunoduarte})}
	\label{fig:communicationattacks}
\end{figure}

\subsubsection{Privacy Enhancement Systems}

The most important concern for a privacy-sensitive mobile application is the way data is managed, specially with valuable data such as health records or banking information. Systems like MockDroid \cite{beresford2011mockdroid} and Zhou et al. \cite{zhou2011taming} are extensions to Android's data access control and prevent untrusted applications from accessing sensitive data by allowing users to manually specify application access rights over the system services. These systems even offer data shadowing \footnote{Data shadow is the return of empty or incorrect information instead of the intended data.} to the unauthorized apps trying to access it. Other systems, like IdentiDroid \cite{shebaro2014identidroid} focus on protecting the identity of the user. This is done by using an anonymous mobile device state to provide data shadowing and permission revocation techniques that disable the ability of apps to use systems services such as location or \ac{IMEI}. This way, if an app is trying to use the devices location, a default location is returned instead of the real one or the application simply cannot access the location service.

Some systems use a different approach to solve the same problem. Dynamic taint analysis systems, such as TaintDroid~\cite{enck2014taintdroid}, prevent data leakage by tainting data with a specific mark and then evaluate how this data is propagated through the system. If this data attempts to leave the system the user is alerted. This system suffers from limitations such as \emph{(i)} tracking a low number of data sources (mainly sensors), \emph{(ii)} performance overheads not tolerable for most mobile environments, \emph{(iii)} the existence of false positives leading to access control circumvention and \emph{(iV)} the incapacity of analysing sensitive information leakage through covert channels.

% será mesmo necessário?
%PODE SAIR
%Despite these limitations, TaintDroid was used by the research community as a building block for other privacy enhancement systems. Kynoid~\cite{schreckling2013kynoid} extends TaintDroid to support a bigger number of information sources, and AppFence~\cite{hornyack2011these} provides a mechanism to block data made available by the user for on-device use only to be transmitted over the network and allows for high level data to be substituted by shadowed data.

\subsubsection{Trusted Execution Environments}
\label{sec:tee}

Trusted execution environments are isolated environments that provide a higher level of security than full-blown rich mobile operating systems by guaranteeing code and data to be loaded inside a small protected execution space.

% ISTO TEM QUE SAIR
% OU ENTAO EXPLICAR UM POUCO MELHOR QUE ESTA DENTRO DESTA CATEGORIA PORQUE O OBJECTIVO É REDUZIR A TCB DO SISTEMA DE UMA FORMA DINAMICA
\paragraph{\textbf{TrUbi}} is a system developed by Duarte \cite{nunoduarte} and Costa \cite{miguelcosta} built on top of ASM \cite{heuser2014asm} allows for flexible system-wide resource restriction, which may be used to isolate privacy-sensitive apps by killing, freezing or revoking permissions to running applications. With TrUbi it is possible to isolate the execution of a critical application from the remaining apps installed on the system, for example, the \ac{PHR} app could be developed with the following premise. When the \ac{PHR} app is running, all the other apps are killed and all the resources blocked. The app could then download the health records from the healthcare provider and show the data to the user. When the user exits the application, their data is encrypted with a key generated from a user password, and only then the resources are released for the other applications. The system was completely isolated during the whole process and the data is stored with encryption (and the key, because it is generated from a user password, is not stored on the system).

\paragraph{\textbf{External hardware security modules}} represent the classic security solution for embedded applications, which is the inclusion of a dedicated trusted element (e.g., a smartcard) that is outside of the main \ac{SoC}. On one hand, the main advantage of this solution is that it allows for the encapsulation of sensitive assets inside a physical device specially designed for robust security. On the other hand, the main disadvantage is that smartcards provide only secure processing and storage functions. This means that some operations (e.g., I/O) must rely on software running outside of the security perimeter to provide the desired features. An example where this happens is when a user interacts with the system by entering a \ac{PIN}. This \ac{PIN} must be managed by the less secure software outside of the smartcard, making it vulnerable to attacks.

\paragraph{\textbf{Internal hardware security modules}} are, contrary to the previous solution, included within the \ac{SoC}. These integrated modules are usually one of two forms: the first is a hardware block designed specifically for managing cryptographic operations and key storage, and the second is a general purpose processing engine, which is placed alongside the main processor, that uses custom hardware logic to prevent unauthorized access to sensitive resources. This solution has the advantage of being cheaper and offering a performance improvement over external hardware security modules like smartcards. The disadvantage is that, like the previous solution, the resources protected by the security module will eventually need to be used outside the module it self, thus making these resources vulnerable. Another disadvantage is that this design requires a separate physical processor, typically less powerful than the main processor, to a avoid sharing such an important resource with less critical modules.

\paragraph{\textbf{Software virtualization}} is another security mechanism which has been growing in popularity over the past years. In this software security mechanism, a highly trusted management layer called hypervisor runs in privileged mode of a general purpose processor. The hypervisor uses a \ac{MMU} to separate several independent software platforms, running each one inside a virtual machine. There are many advantages of using this solution. The first advantage is that a compact hypervisor can be thoroughly tested to ensure, with a high degree of certainty, that software running within one virtual machine cannot influence and attack the execution of others running in parallel. Another advantage is that there is no additional hardware requirement to implement a hypervisor, thus any processor with a \ac{MMU} can be used to implement this security solution. Lastly, this solution supports processing isolation between a secure environment and a full-blown rich operating system running in different virtual machines managed by the hypervisor. If a communication mechanisms is supported by the hypervisor, then a secure pipeline can be established between the two virtual machines.

The main problem with this approach is the isolation provided is restricted to the processor implementing the hypervisor. If all the other resources are not managed by the hypervisor, then the protection provided by the virtualization may be bypassed. Managing resources, like \ac{GPUs}, can be difficult to achieve without hindering the system's performance.

\paragraph{\textbf{TrustZone}} is a hardware architecture that extends the security throughout the system's design. This architecture was designed to mitigate the problems discussed above by allowing any part of the system to be made secure, instead of protecting only the assets inside a secure hardware block, thus enabling end-to-end security without exposing resources to a less critical platform.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.80\textwidth]{img/trustzone.pdf}
	\caption{TrustZone's Software Architecture (adapted from \cite{trustzone_whitepaper})}
	\label{fig:trustzone_architecture}
\end{figure}

TrustZone's hardware and software architecture is described in a whitepaper~\cite{trustzone_whitepaper} by ARM. In a TrustZone-enabled system, a physical processor provides two virtual cores, one considered non-secure and the other secure, as well as a robust context switching mechanism known as monitor mode. The NS bit sent on the main system bus identifies which of the virtual core performed an instruction or data access. Several software architectures can be implemented on the software stack of a TrustZone-enabled processor, but the most powerful one is a dedicated operating system in the secure world, as shown in Figure~\ref{fig:trustzone_architecture}. This design allows for concurrent execution of multiple secure world applications and services that are completely independent of the normal world environment, thus even if the normal world is sabotaged, the secure world executes as expected, without being compromised. Moreover, if the secure world kernel is small and correctly implemented, security applications can execute at the same time without needing to trust each other. The kernel design can enforce the logical isolation of secure tasks from each other, preventing one secure task from tampering with the memory space of another.

\subsubsection{Summary}

After describing and assessing the available technology, one can argue which mechanisms better suit the development of critical mobile applications for Android, such as our \ac{PHR} app. Access control mechanisms and application communication monitoring systems are clearly unsuitable for the goals of this project. These systems may be helpful in developing new access control policies or mitigating vulnerabilities caused by negligent development, but are not sufficient to build privacy-sensitive applications. Privacy enhancement systems focus on detecting and preventing data leakage instead of providing a framework for developers to build privacy-sensitive applications, for this reason these systems do not fulfil the needs of this project. Besides the problems discussed above, all these mechanisms suffer from a critical limitation, both the middleware and the underlying kernel are considered as \ac{TCB}. This means that if a malicious app is capable of compromising these layers, then a critical application is compromised as well, and the data it protects may be accessible by a malicious party. The only solution for the problem described is using a \ac{TEE}. As shown in table~\ref{tab:securityMechanismsComparison}, the \ac{TEE} solutions are the only solutions which work either with a trusted OS and a compromised OS.

To accomplish the goals of this project, a completely secure flow of execution is needed, this means that privacy-sensitive data must never leave the trusted security perimeter. A system which does not support secure I/O greatly limits the functionality offered by a \ac{PHR} application, to the point where it becomes useless. For this reason, both the external and internal hardware security modules were discarded. On a different note, the virtualization solution seems promising, but with all the problems related to sharing resources such as \ac{GPUs} and other system buses, and because total isolation is needed, which is not easily achievable using virtualization by it self, this security module is not appropriate for this project. TrustZone technology seems to be the most complete system of all the \ac{TEE} solutions, as it mitigates recurring problems from other mechanisms. For this reason, the next section will focus on describing some state-of-the-art TrustZone-based systems, as it is the only security mechanism suitable for the needs of this project.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[t!]
	\centering
	\caption{Comparison between security mechanisms with and without a compromised Operating System (Android).}
	\label{tab:securityMechanismsComparison}
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|P{5cm}||P{2.3cm}|P{2.3cm}|P{2.3cm}|P{2.3cm}|}
			\hline
			\multirow{2}{*}{Security Mechanism} & \multicolumn{2}{c|}{Trusted OS}  & \multicolumn{2}{c|}{Compromised OS} \\ \cline{2-5}
			& Confidentiality & Data Integrity & Confidentiality & Data Integrity    \\ \hline \hline
			Access Control Mechanisms			& \cmark 		  & \cmark         & \xmark          & \xmark            \\ \hline
			App Communication Monitoring    	& \xmark          & \xmark         & \xmark          & \xmark            \\ \hline
			Privacy Enhancement Systems         & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
			Digital Rights Management           & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
			TrUbi					            & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
			External Hardware Security	        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
			Internal Hardware Security	        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
			Software Virtualization		        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
			TrustZone        					& \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
			
		\end{tabular}
	}
\end{table}

% TRUSTZONE
\subsection{TrustZone-based Mobile Security Systems}

The research community has been experimenting with trusted execution environments in order to achieve better solutions for common security problems, such as two-factor authentication or cryptographic key generation. Among the available \ac{TEE} supported architectures, ARM's TrustZone is the one which has been used the most by researchers and companies world-wide, this is because the deployment potential for these new security applications is tremendous, as most modern ARM processors support this technology.

%COPIADO, REVER
Several \ac{TEE} software stack implementations have been designed since the concept was formalized around 2007 by the OMTP standardization forum, which issued a set of security requirements on functionality a TEE should support. The GlobalPlatform~\footnote{https://www.globalplatform.org/} organization went a step further by defining standard APIs: on the one hand, the TEE internal APIs that a Trusted Application can rely on, and on the other hand, the communication interfaces that rich OS software can use to interact with its Trusted Applications. It is worth noting that, because the TEE threat model assumes that nothing coming from the rich OS is trustworthy, the designer of a TA (Trusted Application) must assume that the rich-OS-side client of the TA may not be legitimate.

% DIZER TBM QUE SER COMPLIANT COM ESSAS APIS PERMITEM QUE TRUSTED APPS CONSTRUIDAS SOBRE UM TEE FUNCIONAM NOUTRO QUE SUPORTE A API

When surveying the literature, it is clear that TrustZone-based systems can be divided in two separate groups: \ac{GPFR}, and special-purpose \ac{TA}. \ac{GPFR} represent tool kits for building secure special-purpose operating systems or runtimes, which allow the development of Trusted Applications. Special-purpose \ac{TA} are secure applications, built on top of \ac{GPFR} systems, which are executed in the trusted execution environment to achieve a specific security property. With a more thorough analysis, one can divide each of these categories even further, with regards to trusted user interface (UI). Trusted UI is a \ac{TEE} feature capable of ensuring that the correct information is displayed to the user and that this information is secure from the risk of, for instance, password logging, as well as allowing logs and statement information to be securely displayed to the user.

For this reason, this section categorizes TrustZone-enabled systems into four subsections: \emph{(i)} GPFR with Untrusted UI, \emph{(ii)} TA with Untrusted UI, \emph{(iii)} GPFR with Trusted UI and \emph{(iv)} TA with Trusted UI.

% ESTES NOMES ESTAO ESQUISITOS, PERGUNTAR AO PROF POR OUTRO NOME
\subsubsection{GPFR with Untrusted UI}

Most of the \ac{TEE} software stack implementations have similar architectures (similar to the one shown in section~\ref{sec:tee}). This architecture is generally composed of a small trusted kernel running in the isolated secure world of TrustZone-enabled processors, a normal world user space client API and a kernel TEE device driver used to communicate between worlds. OP-TEE~\footnote{https://wiki.linaro.org/WorkingGroups/Security/OP-TEE}, TLK\footnote{http://www.w3.org/2012/webcrypto/webcrypto-next-workshop/papers/webcrypto2014\_submission\_25.pdf}, TLR~\cite{santos2011trusted} and AndixOS~\cite{fitzekandix} are \ac{TEE} implementations which share this general architecture. Although these systems use TrustZone's hardware based isolation to ensure that applications running inside the secure world are not tempered by a compromised rich OS, they were implemented with the goal of reducing the \ac{TCB} in order to ensure a less vulnerable system. there are some limitations regarding the applications it can support.

A reduced \ac{TCB} means that most features of standard mobile operating systems are not supported, for instance, in AndixOS the secure world kernel lacks drivers for peripherals such as the touchscreen or code to control the framebuffer, thus it it is not capable of supporting trusted UI. The same limitations are present in both TLR and OP-TEE. Instead, these sytems support an RPC-like mechanism for in-between-world communication, secure persistence storage and basic cryptographic systems allowing for the development of simple trusted applications.

% COLOCAR AQUI UM EXEMPLO DE ALGUM DOS SISTEMAS ACIMA, POR EXEMPLO DO TLR ?

On-board Credentials (ObC)~\cite{kostiainen2012board} is another \ac{TEE} system which supports the development of secure credential and authentication mechanisms. Originally developed for Nokia mobile devices using the TI M-Shield technology, and later ported to ARM's TrustZone, it suffers from the same limitation described above.

\subsubsection{TA with Untrusted UI}

Trusted Applications are built on top of secure runtimes in order to minimize and mitigate the impact of the normal world on its execution. This subsection describes trusted applications built using runtimes which do not support trusted UI, or TAs which do not require trusted UI to correctly perform its function. Some trusted applications use custom TEEs to fully control the underlying hardware and design specific security solution which may not be supported by generic secure runtimes. 

%REVER PARA FACILITAR A LEITURA
Brasser et al.~\cite{brasserregulating} designed a minimalistic runtime to support the bare minimum necessary for their trusted application to work. This system leverages Android in the normal world and allows for third parties (hosts) to regulate how users (guests) use their devices (e.g., manage their devices’ resources), while in a specific space. This system comprises of authentication and communication mechanisms between guest's secure world and hosts, remote memory operations (reads retrieve certain normal world kernel pages and writes change certain page configurations, e.g., uninstall peripheral drivers, either pointing their interfaces to NULL, or by pointing them to dummy drivers, that just return error codes) and other common features supported by most TEE such as secure boot through TrustZone, with secure world component integrity checks, and world switches based on software interrupts. %COMO SE PODE VER NAO PRECISA DE SECURE UI, dar o exemplo do paper(da figura)?

Other trusted applications are built using generic runtimes and frameworks. DroidVault~\cite{li2014droidvault} introduces the notion of data vault as a protective measure for sensitive data on Android mobile devices. To achieve this, DroidVault adopts the memory manager and interrupt handler from Open Virtualization's SierraTEE~\footnote{http://www.openvirtualization.org/} and is implemented with a data protection manager, encryption library and a port of a lightweight SSL/TLS library called PolarSSL~\footnote{https://polarssl.org/}. Much like the trusted application described above, DroidVault supports world switching through software interrupts and secure boot and even inter-world communication. With this TA a user can securely download a sensitive file from an authority and securely store it in the untrusted Android OS, because secure storage space is limited, and allows an app to process sensitive data but only through data protection managers signed by the data owner running inside the secure world. This system supports trusted input/output by using a secure keyboard and serial console, but because we are interested in trusted user interfaces similar to those offered by mobile operating systems we decided to consider this system as not supporting trusted UI. 

Android Key Store~\footnote{http://developer.android.com/training/articles/keystore.html} is another security service in Android. This service allows for cryptographic keys to be stored in a container (keystore), so its extraction from the device becomes difficult and so they can be used for common cryptographic operations. The encryption and decryption of the container is handled by the keystore service, which in turn links with a hardware abstraction layer module called "keymaster". The android open source project (AOSP) provides a sofware implementation of this module called "softkeymaster", but device vendors can offer support for hardware based protected storage when available by using TrustZone.

\subsubsection{GPFR with Trusted UI}

In this section we describe TEE frameworks and runtimes with support for trusted UI. As referenced before, GlobalPlatform defined standard APIs for the communication between the rich OS running in the normal world and the secure OS, but this organization also defined device specifications which TEEs must comply to in order to be certified. Included in these device specifications is a trusted UI clause, meaning that every TEE which complies with GlobalPlatform's device specifications must support trusted UI. SierraTEE~\footnote{http://www.openvirtualization.org/}, T6~\footnote{https://www.trustkernel.com/products/tee/t6.html} and Open-TEE~\cite{mcgillion2015open} comply with this standard, and for this reason allow the development of trusted applications with secure user interfaces.
Open-TEE's trusted UI feature is being developed by the community as it was not originally supported.

The Genode OS Framework~\footnote{http://genode.org/} is a tool kit for building highly secure special-purpose operating systems to be executed in TrustZone-enabled processors. Genode implements a framebuffer and input drivers to be used by the secure kernel, thus trusted applications running on top of Genode-based TEEs can offer trusted user interfaces. TrustICE~\cite{sun2015trustice} is an isolation framework to provide isolated computing environments (ICEs) on mobile devices. A lot of similar solutions provide isolated computing environments using ARM's TrustZone by allowing code to be executed in the secure world, generally in the form of trusted applications. TrustICE aims at creating ICEs in the normal world domain rather than in the secure world. For this reason, TrustICE' architecture is slightly different for those described before.
% SHOW FIGURE HERE
% EXPLAIN HOW THIS IS DONE BRIEFLY
% TALK ABOUT THE SECURE UI
% FALAR DO EXEMPLO QUE ELES IMPLEMENTARAM
\subsubsection{TA with Trusted UI}

TrustOTP~\cite{sun2015trustotp}

TrustDump~\cite{sun2015reliable}

AdAttester~\cite{li2015adattester}

Samsung KNOX~\cite{knox_whitepaper} É PARECIDO COM O ANTERIOR MAS MAIS ORIENTADO PARA ENTERPRISE BYOD COM SUMSUNG - MOSTRAR ALGUNS EXEMPLOS DE UTILIZAÇAO APRESENTADOS NO WHITEPAPER ASSIM COMO OS MECHANISMOS QUE USA PARA OS POR EM PRATICA
%isto devia ter secure UI mas nao vi isso explicito

TrustUI~\cite{li2014building}\\

CONCLUSAOZITA
\begin{table}[t!]
	\centering
	\caption{TrustZone-based system categorization.}
	\label{tab:trustzonesystemscomparison}
	%\resizebox{\textwidth}{!}{%
	\begin{tabular}{ c|c|c| }
		\multicolumn{1}{c}{} 	& \multicolumn{1}{c}{Untrusted UI} 	& \multicolumn{1}{c}{Trusted UI} \\ \cline{2-3}
		\multirow{5}{*}{TAs} 	&									& \\
								& Android Key Store					& TrustOTP \\
								& DroidVault 						& TrustDump \\
								& Brasser et al.					& AdAttester \\
								& 									& TrustUI \\
								&									& Samsung Knox\\
								&									& \\
								\cline{2-3}
		\multirow{5}{*}{GPFR}	&									& \\
								& TLK								& Genode \\
								& OP-TEE 							& T6 \\
								& Andix OS							& TrustICE \\
								& Nokia ObC							& SierraTEE \\
								& TLR 								& \\
								&									& \\
		\cline{2-3}
	\end{tabular}
	%}
\end{table}

%% Please add the following required packages to your document preamble:
%% \usepackage{graphicx}
%\begin{table}[t!]
%	\centering
%	\caption{Comparison between security mechanisms with and without a compromised Operating System (Android).}
%	\label{tab:trustzonesystemscomparison}
%	\resizebox{\textwidth}{!}{%
%		\begin{tabular}{|P{2.8cm}||P{2.3cm}|P{2.3cm}|P{2.3cm}|P{2.3cm}|P{2.3cm}|}
%			\hline
%			TrustZone-Enabled Systems 		& Secure I/O	& Secure Storage	& Secure World-Switching	& Inter-World Communication 	& Open-Source \\ \hline \hline
%			TrustOTP						& \cmark 		& \cmark    		& \cmark          			& \xmark 						& \xmark \\ \hline
%			TrustICE						& \cmark 		& \cmark    		& \cmark          			& \xmark 						& \xmark \\ \hline
%			TrustDump						& \cmark 		& \cmark    		& \cmark          			& \xmark 						& \xmark \\ \hline
%			DroidVault					    & \cmark    	& \cmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			AdAttester					    & \cmark    	& \cmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			TrustUI					        & \cmark    	& \xmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			VeriUI					        & \cmark    	& \xmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			Genode						    & \cmark    	& \cmark    		& \cmark          			& \cmark 						& \cmark \\ \hline
%			TLR							    & \xmark    	& \cmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			SECRYPT Video					& \cmark   		& \cmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%			Andix OS        				& \xmark    	& \cmark    		& \xmark          			& \cmark 						& \cmark \\ \hline
%			Restricted Spaces  				& \xmark    	& \xmark    		& \xmark          			& \cmark 						& \xmark \\ \hline
%		\end{tabular}
%	}
%\end{table}



