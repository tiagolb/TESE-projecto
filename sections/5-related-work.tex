%!TEX root = ../report.tex

% 
% Related work
% 
% (~17pgs)
\section{Related Work}
\label{sec:relatedWork}

This section describes the related work and is organized in three main parts: mobile health security, general-purpose mobile security mechanisms and TrustZone-based systems.
%FIRST
In order to understand the necessity for secure input and display in critical mobile applications, we must introduce a class of apps which benefit from such security improvements. A representative example of such a class of applications are mobile health apps. For this reason, the first part focuses on presenting the main studies in mobile health security. In particular, it describes the attack surfaces of mHealth apps, the most common threats and their seriousness.
%SECOND
In the second part of this section, we overview the state of the art of general-purpose mobile security mechanisms used to implement most secure sensitive applications, such as those described in the first part. We also explain why such mechanisms fall short in supporting secure output to these apps.
%THIRD
Finally, the third part describes a specific class of security systems which, similarly to \emph{ViewZone}, leverage TrustZone to implement a variety of security solutions for mobile platforms.

\subsection{Studies in Mobile Health Security}
\label{sec:mhealth}

Medical data is highly profitable for malicious agents who use it for medical identity theft, as it can be more valuable than credit card information. Generally, vulnerabilities which lead to sensitive data leakage originate from negligent development of healthcare systems. For this reason, regulatory laws such as the \ac{HIPAA} have been established. These laws comprise the standard for electronic healthcare transactions and must be followed by all developers when managing sensitive health data.

In the mobile context, data is even more exposed and vulnerable due to the inherent portability of these devices, the sharing of information to third-party advertisers by device manufacturers or mobile app developers, unregulated management of sensitive medical information, specially because regulatory laws such as \ac{HIPAA} do not account for the mobile sector, and because of security flaws on consumer device software, which may lead to a malware compromised system. This is why there is a need for a novel security system capable of allowing applications to securely display and manage sensitive data.

The following subsections describe work done in assessing the current security state of the art of commercial mobile health applications as to better understand the need for a secure content display capability. The first subsection describes a threat taxonomy for mHealth applications by Kotz~\cite{kotz2011threat}. The second and third subsections describe work done by He et al.~\cite{he2014security} through the analysis of three studies which answer the following questions: what are the potential attack surfaces, how widespread and how serious are these security threats.

\subsubsection{Threat Taxonomy for Mobile Health Applications}

Kotz~\cite{kotz2011threat} defines a threat taxonomy for mHealth and categorizes threats in three main categories: \emph{identity threats}, \emph{access threats} and \emph{disclosure threats}.

\emph{Identity threats} are described as a mis-use of patient identities and include scenarios where a patient may lose (or share) their identity credentials, allowing malicious agents to access their respective \ac{PHR}. \emph{Insiders} (authorized \ac{PHR} users, staff of the \ac{PHR} organization or staff of other mHealth support systems) may also use patient identities for medical fraud or for medical identity theft, and \emph{outsiders} may be able to observe patient identity or location from communications.
%tempo verbal no their? nao entendi

\emph{Access threats} are described as unauthorized access to \ac{PHR} and include scenarios where the patient, which controls the data, allows broader-than-intended access or disclosure of information, \emph{insiders} who may snoop or modify patient data with malicious intent, and even \emph{outsiders} which, by breaking into patient records, may leak or modify this data.
% QUEREMOS RESOLVER ESTES

\emph{Disclosure threats} include scenarios where an adversary captures network packets in order to obtain sensitive health data. This problem can be mitigated by using strong encryption methods. But even if the network traffic is encrypted it is possible to analyse the traffic to determine its characteristics~\cite{wright2006inferring}. The adversary may also use physical or link layer fingerprinting methods to identify the device type and inject or selectively interfere with wireless frames.

Avancha et al.~\cite{avancha2012privacy} developed a privacy framework for privacy-sensitive mobile health systems. A developer should use the list of privacy properties provided by this article as a check-list to be considered in any design. But even these security properties are not sufficient to withstand an attack leveraged by a compromised operating system, which is an attack not explicitly described in the above taxonomy. For this reason, there is a need for a security solution capable of withstanding such attacks whilst protecting sensitive information.
 
\subsubsection{Potential Attack Surface of Commercial Mobile Health Applications}

He et al.~\cite{he2014security} analysed several mHealth applications available in Android's app store to contribute to the understanding of security and privacy risk on the Android platform. In the first of three studies described, 160 apps were analysed to find evidence of security threats. From surveying previous literature, seven attack surfaces, shown in Table~\ref{tab:attacksurfaces}, are determined to be in need of protection.

\begin{table}[t]
	\caption {Description of attack surface (taken from He et al. \cite{he2014security})}
	\label{tab:attacksurfaces}
	\begin{tabular}{|>{\raggedright}p{2cm}|>{\raggedright\arraybackslash}p{10cm}|}
		\hline
		\textbf{Attack Surface}      & \textbf{Description}                                                                                                                    \\ \hline
		Internet            & Sensitive information is sent over the internet with unsecure protocols (e.g. HTTP), misconfigured HTTPS, etc.                 \\ \hline
		Third Party         & Sensitive information is stored in third party servers                                                                         \\ \hline
		Bluetooth           & Sensitive information collected by Bluetooth-enabled health devices can be sniffed or injected                                 \\ \hline
		Logging             & Sensitive information is put into system logs where it is not secured                                                          \\ \hline
		SD Card Storage     & Sensitive information is stored as unencrypted files on SD card, publicly accessible by any other app                          \\ \hline
		Exported Components &  Android app components, intended to be private, are set as exported, making them accessible by other apps                     \\ \hline
		Side Channel        & Sensitive information can be inferred by a malicious app with side channels, e.g. network package size, sequence, timing, etc. \\ \hline
	\end{tabular}
\end{table}

Table~\ref{tab:attacksurfaces} is an overview of the problems disclosed by the apps studied, where applications send unencrypted information or use misconfigured internet protocols, store data in third-party server, where data is not assured to be secure, inadvertently log sensitive data to the system or export private app components, making them accessible to other applications. Table~\ref{tab:attacksurfaces} is missing an important attack surface, which is the operating system. Although usually well protected and in constant update to mitigate vulnerabilities found in previous versions, operating systems have an extensive and complex code base, and there are no security guarantees that the system will never be compromised by malware, which can then control system resources and the overlying applications. Resources, such as the framebuffers or touchscreen device, might be explored by a malicious agent in order to disclose data, such as sensitive medical information.

The authors also document that most apps targeted for patients (60\%) are in the Life Management category, which comprises apps nutrition and fitness, followed by apps that manage and synchronize user health information (\ac{PHR} Management), which occupy nearly half (46.88\%) of these applications. These numbers are a good indicator of the data handled by most commercial mHealth apps available, as well as which health apps are more used in the mobile health sector. These numbers also motivate the choice made to build a personal health record manager, implemented using \emph{ViewZone}, in order to demonstrate the security solution features and properties, namely secure display, input and storage of sensitive data.

\subsubsection{Severity of Attacks to Mobile Health Applications}
In the second study by He et al.~\cite{he2014security}, 27 of the top 1080 free apps from the Medical and Health \& Fitness categories on Google Play were analysed in order to assess the most commonly observed vulnerabilities. From this analysis, three attack surfaces are identified as the most important ones: \emph{Internet}, \emph{Third Party Services} and \emph{Logging} (see Table~\ref{tab:attacksurfaces}).

Only 7 of the 27 apps use the Internet to effectively send medical information over to remote servers. Some of these apps send unencrypted content, which generally include emails, usernames and passwords. This study also concludes that most of these apps are hosted, and store the recorded data, on third party servers. This is an economical and scalable solution for mobile applications, but storing sensitive health records on third party servers can have serious implications, mostly because users are not capable of assessing whether this data is encrypted in such a way that hosting companies do not have access to it.

In the third study by He et al.~\cite{he2014security}, another 22 apps, which send information over the Internet, are randomly selected from the same top 1080 apps and audited to understand what information is effectively being sent, thus inferring the seriousness of the threats. The conclusion is that, when used as intended, these apps gather, store and transmit a variety of sensitive user data, which includes at least personal profiles, health sensor data, lifestyle data, medical browsing history and third-party app data (e.g. Facebook account information).

The consequences of data breaches, information disclosure or tampering with sensitive health data depend on the type, sensitivity and volume of data breached, but it is clear that profiling, medical identity theft and healthcare decision-making errors are all possible. This is why the authors suggest the use of encryption for communication and storage, and encourage developers to create a set of standard security and privacy guidelines that offer a baseline for protection. However, these measures are not sufficient to protect sensitive data against more complex attacks, such as those which involve a malware compromised operating system. In such a system, where the malicious entity controls system resources, encryption techniques and good developing guidelines might not be enough as the system can bypass these mechanisms and disclose data when it is in its raw displayable form, i.e., unencrypted.\\

Security measures and regulatory laws are implemented for custom healthcare information systems in order to mitigate attacks which may disclose sensitive medical data. However, in the mobile sector, these security measures may not be possible or practical to implement, and regulatory laws, such as \ac{HIPAA}, do not account for the mobile market. For this reason, the research community analysed and categorized mHealth threats, developed a privacy framework and studied commercially available apps in order to achieve a standardized set of rules to mitigate negligent development. But these studies consider the whole operating system as the trusted computing base for mHealth apps, and, because this \ac{TCB} is so complex and unreliable, malware may take control of system resources and consequently leak sensitive data. Ultimately, what the mHealth market needs is a security solution which provides secure primitives that both developers and users desire, such as secure display, input and storage, without having to rely on a full-featured operating system, inherently with a large \ac{TCB}.

\subsection{General-Purpose Mobile Security Mechanisms}

This section describes the security mechanisms available for the Android platform. Since many security mechanisms have been proposed, we divide them into groups to reflect the different ways in which sensitive information is protected: \emph{(a)} access control mechanisms, which enforce security policies that prevent access to sensitive resources by a given application, \emph{(b)} application communication monitoring, which ensures that sensitive data that was read by a given application can be securely exchanged with co-located applications, \emph{(c)} privacy enhancement systems, which aim at preventing privacy breaches by applications that read sensitive data and need to share it with Internet services, and \emph{(d)} trusted execution systems, which provide restricted environments in which sensitive data can be processed while trusting in a smaller code base than that of a rich OS. Figure~\ref{fig:relwork} maps these four groups to a representation of a possible mobile system.

%BEFORE
%The security mechanisms addressed are divided in four groups: \emph{(a)} access control mechanisms, \emph{(b)} application communication monitoring, \emph{(c)} privacy enhancement systems and \emph{(d)} trusted execution environment.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.65\textwidth]{img/relwork.pdf}
	\caption{Security Mechanisms Map; A-application, R-system resource}
	\label{fig:relwork}
\end{figure}

\subsubsection{Access Control Mechanisms}

%Não ponhas em bold-itálico; ao fim e ao cabo, isto é o título da subsecção. ENTAO FAÇO O QUE?
\paragraph{\textbf{Access control mechanisms}} implement security models in which subjects (e.g. user, processes, threads, etc.) are constrained by a security policy to perform certain actions on the system, namely access to resources (e.g. files, sensors, etc.), typically called objects. Android inherits a \ac{DAC} mechanism from its Linux based kernel, but some system resources, such as the IPC Binder mechanism, are accessed via \ac{MAC} policies. In a \ac{DAC} system the data owner is responsible for the data and, as such, determines who can access it. In Android, an application can create and store files in the filesystem, thus becoming the sole owner of such files, and it can allow access to them for any other application. In \ac{MAC}, subjects are much more restricted in determining specific permissions because the restrictions on these resources are defined by a global system policy. In the Android operating system, once a subject attempts to access an object, it triggers a policy evaluation by the kernel, which assesses whether the access is granted. The advantage of this strict system is its robustness and restrictiveness, because subjects cannot override or modify the security policy. In Android, applications must specify in their manifest the permissions they require at runtime, and after the installation neither applications nor users have any control over the access policies.

Because \ac{MAC} is more restrictive, several systems were created over the years to extend \ac{MAC}'s access control model to other Android resources. SEAndroid~\cite{smalley2013security} solves problems related to resources complying with the \ac{DAC} mechanism. The authors ported SELinux~\cite{peter2001integrating} to provide \ac{MAC} at the kernel layer. The kernel was then modified to support a new \ac{MAC} policy (e.g., filesystem, IPC) and a new middleware layer (MMAC) was created to extend \ac{MAC} to Android's Binder IPC. TrustDroid~\cite{bugiel2011practical} extends the \ac{MAC} mechanism to all the platform's resources in order to isolate different domains' sensitive information.

\paragraph{\textbf{Permission Refinement}}

The Android permission mechanism is a very restricted system. At install time, the list of permissions an application specifies in its manifest is shown to the user, which is forced into a binary decision, either granting all permissions or quitting the installation. Furthermore, some of these applications may even require more permissions than those effectively needed. This is an inflexible solution, which makes it impossible for users to have full control over the permissions an application effectively requires at runtime. This inflexibility allows an app to use the device's resources without the user's knowledge, possibly with malicious intent.

Over the years, many systems aimed at improving the state of affairs through permission refinement. APEX~\cite{nauman2010apex} modified Android's permission model to allow users to specify the assignment of permissions to each app, both at install and runtime. Permission Tracker~\cite{kern2012permission} allows users to be informed on how permissions are used at runtime and offers the possibility of revoking those permissions. Furthermore, a user can specify which permissions are of interest so they can be notified of every permission access and decide whether to grant or deny that access. These systems improve the original Android permission model, but require manual configuration by the user. % tempo verbal no they
A more useful solution would be to use a context-aware system to handle the permissions at runtime. This way it may be possible to automatically restrict permissions to all applications running along side a security sensitive app, thus isolating this application and avoiding possible leaks by shared resources.

There are several context-aware permission refinement systems developed by the research community. Trusted third parties can use CRePE~\cite{conti2011crepe} to enforce security policies on other devices. For example, an employer may enforce a security policy on the employees' mobile devices when inside the company. Similarly, MOSES~\cite{russello2012moses} enforces domain isolation through the concept of security profiles, allowing it to switch security profiles based on pre-established conditions (e.g., GPS coordinates and time). Additionally, MOSES leverages TaintDroid~\cite{enck2014taintdroid} to prevent apps from one profile to access data belonging to another. Both CRePE and MOSES suffer from a device control issue where a third party defines a policy that cannot be revoked by the user. Moreover, a user has no way to deny the enforcement of a third party policy. 

\paragraph{\textbf{Access Control Hook APIs}}

Most security extensions, such as CRePE~\cite{conti2011crepe} or MOSES~\cite{russello2012moses}, require modifying and adding components to the kernel and middleware layers in order to implement new security models. Some frameworks, such as \ac{ASM}~\cite{heuser2014asm} and \ac{ASF}~\cite{backes2014android}, were built in order to ease this development process. These frameworks allow developers to easily create new security models as ordinary Android applications whilst benefiting from a full callback system, which allow apps to be notified of accesses to resources of interest.

These frameworks comprise a set of hooks distributed among the kernel and middleware layers, which can be registered by a secure application. When a hook is activated it triggers a callback from the Hook API module, which in turn is forwarded to the app for verification. The app then decides if the operation that triggered the hook activation may or may not proceed. The main advantage of these frameworks is the flexibility and freedom given to developers in choosing whatever resources to manage.

\paragraph{\textbf{Memory Instrumentation}}

Memory instrumentation leverages application code analysis techniques to restrict access from those applications to the corresponding resources, thus can be used as an access control mechanism. Memory instrumentation can be divided in two groups: static memory instrumentation and dynamic memory instrumentation. While static memory instrumentation changes already compiled bytecode, dynamic instrumentation patches running processes, and for this reason it supports the enforcement of new security models. DeepDroid~\cite{wang2015deepdroid} relies on dynamic memory instrumentation to enforce fine-grained context-aware security policies for enterprise and does this by patching several system services and tracing system calls to resources of interest.

\paragraph{\textbf{Digital Rights Management}} is a specific access control technology which allows data owners to restrict if and how their data can be copied and also how it can be handled once transferred to another device. The \ac{DRM} ecosystem is composed of the following entities:

\begin{itemize}
	\item[$\bullet$] \emph{User} - human user of the DRM Content;
	\item[$\bullet$] \emph{Content Issuer} - entity that delivers the content;
	\item[$\bullet$] \emph{Rights Issuer} - entity responsible for assigning permissions and constraints to \ac{DRM} content;
	\item[$\bullet$] \emph{Rights Object} - XML document generated by a Rights Issuer expressing the restrictions associated to the content;
	\item[$\bullet$] \emph{\ac{DRM} Agent} - trusted entity responsible for enforcing permissions and constraints upon the \ac{DRM} content.
\end{itemize}

The \ac{OMA} developed a DRM standard~\cite{drm} which defines the format of the content delivered to DRM Agents, as well as the way this content can be transferred from the Content Issuer to the DRM Agent. Android provides an extensible DRM framework, called Android DRM Framework~\footnote{http://developer.android.com/reference/android/drm/package-summary.html}, allowing application developers to enable their apps to manage rights-protected content by complying with one of the supported DRM schemes (specific mechanisms, enforced by DRM Agents, to handle particular types of files).

To understand how \ac{DRM} works in the context of mHealth one can suggest the simple example of a \ac{PHR} mobile health application. In this scenario, the healthcare provider (e.g. a hospital) would be the \emph{content issuer}, and it would use a \emph{rights issuer} to assign the restrictions imposed upon the \ac{DRM} content, which in this case would be the personal health record of a patient, when this content is transferred to the patient's device. When using \ac{DRM}, the patient is limited to access the content through a \emph{\ac{DRM} Agent}. Although this solution seems to fit the security properties a critical application requires, once again the whole operating system is considered as trusted computing base, and resources shared by different applications such as the framebuffers and display devices may leak sensitive information if the system would become compromised.

\subsubsection{Application Communication Monitoring}

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.95\textwidth]{img/communicationattacks.png}
	\caption{Confused deputy attack (a); Collusion attack (b) - (taken from Duarte \cite{nunoduarte})}
	\label{fig:communicationattacks}
\end{figure}

The Android operating system implements a middleware mechanism called Inter-Process Communication (IPC) which allows different processes, i.e. applications, to communicate between each other and controls how apps access system components. But this mechanism can be abused such that applications access unauthorized resources or data. In this section we describe two attacks on Android's IPC mechanism followed by systems developed to mitigate such attacks. The attacks described are called \emph{Confused Deputy Attacks} and \emph{Collusion Attacks} and are represented in Figure~\ref{fig:communicationattacks}.

Confused deputy attacks basically consist of unprivileged applications taking advantage of other applications’ publicly accessible APIs to perform an unauthorized action. If App 2 publicly allows other apps to use the Internet through its API, then the user is unaware that App 1 can use the Internet without explicitly requesting it in its manifest. Collusion attacks consist of an app, which might not have permission to perform an operation, still being able to perform it if there exists another app, belonging to the same developer and installed on the user’s device, with the permission to perform said operation. This happens because Android’s permission system is based on UIDs.

Confused deputy attacks allow applications to use resources without explicitly specifying the necessary permission to do so, and to mitigate such attacks the research community developed Saint~\cite{ongtang2012semantically} and QUIRE~\cite{dietz2011quire}. Saint was created to specify which apps can access the public APIs of another app. QUIRE denies access to an API if in the message exchanged between apps, which contains the full call chain context, the source of the request does not have the necessary permission to access the corresponding data.

Collusion attacks are based on a malicious developer building a legitimate application and persuading the user to install a second app with different permissions. Both apps can collude to leak sensitive information by cooperating with each other. XManDroid~\cite{bugiel2011xmandroid} extends the Android permission model in order to support policies that could constrain the way apps interact with each other. This system prevents data leakage or other types of collusion attacks by developing a graph at runtime with a representation of the apps’ interactions, which is then used to regulate inter-app communication.

\subsubsection{Privacy Enhancement Systems}

The biggest concern for privacy-sensitive mobile applications is sensitive data leakage, specially with valuable data such as health records. In this section we describe systems which control the flow of sensitive data in order to assess whether such data leaves the systems as a consequence of a malicious action. Systems like MockDroid~\cite{beresford2011mockdroid} and TISSA~\cite{zhou2011taming} are extensions to Android's data access control mechanism and prevent untrusted applications from accessing sensitive data by allowing users to manually specify application access rights over the system services, such as geographic location.

Other systems, like IdentiDroid~\cite{shebaro2014identidroid} focus on protecting the identity of the user. This is done by using an anonymous mobile device state to provide data shadowing~\footnote{Data shadow is the return of empty or incorrect information instead of the intended data.} and permission revocation techniques that disable the ability of apps to use system services such as location or \ac{IMEI}. This way, if an app is trying to use the device's location, a default location is returned instead of the real one or the application simply cannot access the location service.

Some systems use a different approach to solve the sensitive data disclosure problem. Unlike data access control mechanisms, dynamic taint analysis systems, such as TaintDroid~\cite{enck2014taintdroid}, prevent data leakage by tainting data with a specific mark and then evaluate how this data is propagated through the system. If this data attempts to leave, then the user is alerted. This system suffers from limitations such as \emph{(i)} tracking a low number of data sources (mainly sensors), \emph{(ii)} performance overheads not tolerable for most mobile environments, \emph{(iii)} the existence of false positives leading to access control circumvention and \emph{(iv)} the incapacity of analysing sensitive information leakage through covert channels.
%Existem mais sistemas baseados no taindroid para fazer isto. Podes adicionar uma frase que os cita.

Although these systems can be leveraged in order to understand if sensitive data is leaving the system through network sinks, they fall short in assessing whether data is accessed via shared resources such as framebuffers and display devices, meaning that a compromised OS may access such resources and disclose sensitive information.

\subsubsection{Trusted Execution Systems}
\label{sec:tee}

%Faz melhor a ligação para se perceber porque estiveste a falar de privacy systems e agora de trusted execution. Relaciona isso com o teu objectivo final que é implementar canais de output seguros para as aplicações móveis.
All previously discussed systems fail at isolating the execution environment for critical mobile applications, and because of this the trusted computing base includes the full-featured operating system responsible for the apps execution. Trusted execution systems disable specific software components of the system and ensure that sensitive application code and data are loaded into a restricted execution environment, thus reducing the trusted computing base.

\paragraph{\textbf{TrUbi}} is a system, developed by Duarte \cite{nunoduarte} and Costa \cite{miguelcosta}, built on top of ASM \cite{heuser2014asm} which allows for flexible system-wide resource restriction. This system may be used to isolate privacy-sensitive apps by killing, freezing or revoking permissions to running applications. With TrUbi it is possible to isolate the execution of a critical application from the remaining apps installed on the system, for example, a simple \ac{PHR} app to display and store personal health records could be developed with the following premise. When the \ac{PHR} app is running, all the other apps are killed and all the resources blocked. The app could then download the health records from the healthcare provider and show the data to the user. When the user exits the application, their data is encrypted with a key generated from a user password, and only then the resources are released for the other applications. The system was completely isolated during the whole process and the data is stored with encryption (and the key, because it is generated from a user password, is not stored on the system).

Although TrUbi effectively reduces the TCB dynamically by disabling concurrent running processes, it still trusts the operating system's code base which may be compromised by malware. Furthermore, TrUbi has no support for trusted UI meaning that a compromised OS can access sensitive data by disclosing the content of resources such as graphical framebuffers and display devices. The following systems allow for a more significant reduction of the trusted computing base by isolating the execution environment of sensitive code from that of a full-featured operating system.

\paragraph{\textbf{External hardware security modules}} represent the classic security solution for embedded applications, which consists in the inclusion of a dedicated trusted element (e.g., a smartcard) that is outside of the main \ac{SoC}. On one hand, the main advantage of this solution is that it allows for the encapsulation of sensitive assets inside a physical device specially designed for robust security. On the other hand, the main disadvantage is that smartcards provide only secure processing and storage functions. This means that some operations (e.g., I/O) must rely on software running outside of the security perimeter to provide the desired features. An example where this happens is when a user interacts with the system by entering a \ac{PIN}. This \ac{PIN} must be managed by the less secure software outside of the smartcard, making it vulnerable to attacks. Meaning that, although this security solution does not trust the code base of a full-featured OS to achieve its goals, it requires some untrusted interaction with the rich OS in order to offer additional features such as content display, which cannot be trusted as it relies on information received from the untrusted rich OS.

\paragraph{\textbf{Internal hardware security modules}} are, contrary to the previous solution, included within the \ac{SoC}. These integrated modules are usually one of two forms: the first is a hardware block designed specifically for managing cryptographic operations and key storage, and the second is a general purpose processing engine, which is placed alongside the main processor, that uses custom hardware logic to prevent unauthorized access to sensitive resources. This solution has the advantage of being cheaper and offering a performance improvement over external hardware security modules like smartcards. The disadvantage is that, like the previous solution, the resources protected by the security module will eventually need to be used outside the module it-self. Another disadvantage is that this design requires a separate physical processor to avoid sharing such an important resource with less critical modules.
% TODO ENTREGA - como assim?
% Dá um exemplo de um recurso controlado para se perceber melhor do que estás a falar

Because both the external and internal hardware security modules require the sensitive content to eventually be used outside the isolated environment, for instance for display purposes, there is still the need to eventually trust in the OS to support additional features. The next systems solve this problem by allowing complete isolation between different execution environments.

\paragraph{\textbf{Software virtualization}} is a software security mechanism with a highly trusted management layer called hypervisor, which runs in privileged mode of a general purpose processor. The hypervisor uses a \ac{MMU} to separate several independent software platforms, running each one inside a virtual machine. There are many advantages of using this solution. The first advantage is that a compact hypervisor can be thoroughly tested to ensure, with a high degree of certainty, that software running within one virtual machine cannot influence and attack the execution of others running in parallel. Another advantage is that there is no additional hardware requirement to implement a hypervisor, thus any processor with a \ac{MMU} can be used to implement this security solution. Lastly, this solution supports processing isolation between a secure environment and a full-blown operating system running in different virtual machines managed by the hypervisor. If a communication mechanism is supported by the hypervisor, then a secure pipeline can be established between the two virtual machines.
% Tens que citar alguma coisa aqui.
%TODO ENTREGA
% NAO TENHO O QUE CITA, ISTO FOI TIRADO DO WHITEPAPER DA ARM TRUSTZONE
The main disadvantage with this approach is that having another software component managing resources, such as GPUs, has a high impact on system performance. For this reason a new hardware architecture was designed to offer the benefits of software virtualization without the disadvantages of running additional software components.

\paragraph{\textbf{TrustZone}} is a hardware architecture designed to allow for the execution of an isolated small kernel inside trusted hardware. With this architecture, the sensitive data can be completely isolated from the full-featured operating system, and trusted applications can execute without relying on large and complex code base. TrustZone also mitigates performance overheads inherent to software virtualization techniques since the hypervisor mechanism, which manages the trusted and untrusted domains, is implemented natively in hardware.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.80\textwidth]{img/trustzone.pdf}
	\caption{TrustZone's Software Architecture (adapted from \cite{trustzone_whitepaper})}
	\label{fig:trustzone_architecture}
\end{figure}

TrustZone hardware and software architecture are described in a whitepaper~\cite{trustzone_whitepaper} by ARM. In a TrustZone-enabled system, a physical processor provides two virtual cores, one considered non-secure and the other secure, as well as a robust context switching mechanism known as monitor mode. The NS bit sent on the main system bus identifies which of the virtual cores performed an instruction or data access. Several software architectures can be implemented on the software stack of a TrustZone-enabled processor, but the most powerful one is a dedicated operating system in the secure world, as shown in Figure~\ref{fig:trustzone_architecture}. This design allows for concurrent execution of multiple secure world applications and services that are completely independent from the normal world environment, thus, even with a compromised normal world, the secure world executes as expected. Moreover, the kernel design can enforce the logical isolation of secure tasks from each other, preventing one secure task from tampering with the memory space of another.

\subsubsection{Summary}

After describing the state of the art of general-purpose mobile security mechanism, we discuss which systems have the potential to support the development of critical applications with embedded secure displays.

Access control mechanisms focus on restricting access to system resources, which may be useful for critical applications if these can use it to limit the access to shared resources by less sensitive applications running in parallel. But these mechanisms rely on a full-blown operating system, with a large and complex TCB, to ensure this property, which may become compromised by malware and sabotage these security measures. Moreover, these systems do not offer trusted user interfaces as they provide no explicit isolation between the operating system and resources such as display devices and framebuffers. For these reasons, access control mechanisms do not fulfil the needs of this project.

Application communication monitoring focuses on assuring that communication attacks cannot effectively target Android's IPC mechanism, which is the main communication component between applications in the Android platform. Because these systems are not meant to be used for the development of applications, but rather as a protective measure against specific attacks, these mechanisms are not suitable to solve the underlying problem of developing critical applications to securely display and store sensitive data.

Privacy enhancement systems focus assessing whether sensitive data leaves the system via network sinks. While these systems are useful in controlling the data flow of traditional paths, such as Android's IPC, it falls short of controlling the data flow of unconventional paths, such as framebuffers and display devices, meaning that sensitive data may be intercepted by a malicious OS without the privacy enhancement system knowing it.

Trusted execution systems focus on supporting an isolated environment which comprises a smaller TCB than that of a full-featured operating system. This category comprises very different systems, with different purposes and approaches, which we summarize next. TrUbi dynamically reduces the overall system's TCB while a critical application is runnning, but this is done whilst relying on the operating system, meaning that a compromised OS may compromise the systems execution.

External and internal hardware security modules offer an isolated hardware-based environment for the execution of secure tasks. But because both external and internal modules provide only secure processing and storage functions, the data it protects must eventually be used outside the isolated environment, for instance for display purposes. This means that these systems still rely on the untrusted OS for functionality such as trusted UI, which we want to be supported by the secure environment.

Software virtualization leverages a trusted software layer called hypervisor which supports total isolation between execution environments by running each system inside a virtual machine. In addition, because this software layer manages all system resources, instead of the rich OS, it can securely support trusted user interfaces because sensitive data never reaches the untrusted domain if the hypervisor clears the shared resources before hand. The main disadvantage of this approach is the performance overhead of having another software component managing resources, which greatly hinders the overall performance.

Lastly, TrustZone also supports trusted user interfaces by controlling the necessary peripherals. It also supports isolated environments running along side one another, but, unlike software virtualization, TrustZone leverages special purpose hardware to isolate both domains, which mitigates the performance overhead problem. For this reason, TrustZone will be discussed in depth in the next section, as it supports all the features necessary to implement \emph{ViewZone}. 

%After describing and assessing the available technology, one can argue which mechanisms better suit the development of critical mobile applications for Android, such as our \ac{PHR} app. Access control mechanisms and application communication monitoring systems are clearly unsuitable for the goals of this project.
%%Aqui, é preciso focar claramente no objectivo do teu projecto: (1) suportar um mechanismo de trusted output, e (2) ter pequena TCB.
%These systems may be helpful in developing new access control policies or mitigating vulnerabilities caused by negligent development, but are not sufficient to build privacy-sensitive applications. % porquê?
%Privacy enhancement systems focus on detecting and preventing data leakage instead of providing a framework for developers to build privacy-sensitive applications, for this reason these systems do not fulfil the needs of this project. % muito vago. Mais claro.
%Besides the problems discussed above, all these mechanisms suffer from a critical limitation, both the middleware and the underlying kernel are considered as trusted computing base. This means that if a malicious app is capable of compromising these layers, then a critical application is compromised as well, and the data it protects may be accessible by a malicious party. The only solution for the problem described is using a \ac{TEE}. % vago
%%As shown in table~\ref{tab:securityMechanismsComparison}, the \ac{TEE} solutions are the only solutions which work either with a trusted OS and a compromised OS.
%
%To accomplish the goals of this project, a completely secure flow of execution is needed, this means that privacy-sensitive data must never leave the trusted security perimeter. %o que é o trusted security perimeter? dizer que é para nao fazer o leakage
%A system which does not support secure I/O greatly limits the functionality offered by a \ac{PHR} application, to the point where it becomes useless. For this reason, both the external and internal hardware security modules were discarded. On a different note, the virtualization solution seems promising, but with all the problems related to sharing resources such as \ac{GPUs} and other system buses, and because total isolation is needed, which is not easily achievable using virtualization by it self, this security module is not appropriate for this project. TrustZone technology seems to be the most complete system of all the \ac{TEE} solutions, as it mitigates recurring problems from other mechanisms. For this reason, the next section will focus on describing some state-of-the-art TrustZone-based systems, as it is the only security mechanism suitable for the needs of this project.

%% Please add the following required packages to your document preamble:
%% \usepackage{graphicx}
%\begin{table}[t!]
%	\centering
%	\caption{Comparison between security mechanisms with and without a compromised Operating System (Android).}
%	\label{tab:securityMechanismsComparison}
%	\resizebox{\textwidth}{!}{%
%		\begin{tabular}{|P{5cm}||P{2.3cm}|P{2.3cm}|P{2.3cm}|P{2.3cm}|}
%			\hline
%			\multirow{2}{*}{Security Mechanism} & \multicolumn{2}{c|}{Correct OS}  & \multicolumn{2}{c|}{Compromised OS} \\ \cline{2-5}
%			& Confidentiality & Data Integrity & Confidentiality & Data Integrity    \\ \hline \hline
%			Access Control Mechanisms			& \cmark 		  & \cmark         & \xmark          & \xmark            \\ \hline
%			App Communication Monitoring    	& \xmark          & \xmark         & \xmark          & \xmark            \\ \hline
%			Privacy Enhancement Systems         & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
%			Digital Rights Management           & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
%			TrUbi					            & \cmark          & \cmark         & \xmark          & \xmark            \\ \hline
%			External Hardware Security	        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
%			Internal Hardware Security	        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
%			Software Virtualization		        & \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
%			TrustZone        					& \cmark          & \cmark         & \cmark          & \cmark            \\ \hline
%		\end{tabular}
%	}
%\end{table}
% Confesso que não sei bem a que te referes com confidentiality e integrity; estes sistemas são muito diferentes uns dos outros...

% TRUSTZONE
\subsection{TrustZone-based Mobile Security Systems}

The research community has been experimenting with hardware security architectures in order to achieve better solutions for common security problems, such as two-factor authentication or cryptographic key generation. Among the available security architectures there is ARM's TrustZone technology, a trusted hardware which allows the development of a diverse set of security systems and services, such as Samnsung KNOX and DroidVault. TrustZone is becoming popular as it supports code to be executed isolated from a full-featured operating system such as Android. This allows for a reduced trusted computing base on the critical applications running in the isolated environment.

One of the most important uses of TrustZone is building trusted execution environments (TEE), which are compact systems running in the secure world to provide an isolated environment for critical applications. Since its formal standardization by the OMTP in 2007, several \ac{TEE} software stack architectures have been implemented. This standard comprises a set of security requirements on functionality a TEE should support. The GlobalPlatform~\footnote{https://www.globalplatform.org/} organization went a step further by defining standard APIs: on the one hand, the TEE internal APIs that a trusted application can rely on, and on the other hand, the communication interfaces that rich OS software can use to interact with its trusted applications.

When surveying the literature, TrustZone-based systems can be divided in two separate groups: Trusted Kernels, and special-purpose Trusted Services. Trusted Kernels, which comprise the TEEs, allow the execution of generic code in the secure world environment, whilst a Trusted Service implements a specific application in the secure domain. With a more thorough analysis, one can divide each of these categories even further, with regards to trusted user interface (UI). A TrustZone-based system features Trusted UI capability if it allows secure world components to directly access the mobile interface without interference from the rich OS, thus minimizing the risk of, for instance, password logging.

This project is meant to solve a specific problem, which is allowing Android applications to use a trusted service in order to securely display sensitive content. As such, \emph{ViewZone} can be considered as a Trusted Service with trusted UI, which fits the second quadrant of Table~\ref{tab:trustzonesystemscomparison}.
The remainder of this section categorizes TrustZone-enabled systems into four subsections: \emph{(i)} Trusted Kernels with Untrusted UI, \emph{(ii)} Trusted Services with Untrusted UI, \emph{(iii)} Trusted Kernels with Trusted UI and \emph{(iv)} Trusted Services with Trusted UI. Table~\ref{tab:trustzonesystemscomparison} categorizes the systems described in the following subsections.
% TODO ENTREGA
% Não me chocaria se dissesses à partida em que quadrante encaixarias o sistema que queres conceber e porquê.
\begin{table}[t!]
	\caption{TrustZone-based system categorization.}
	\label{tab:trustzonesystemscomparison}
	\centering
	%\resizebox{\textwidth}{!}{%
	\begin{tabular}{ c|c|c| }
		\multicolumn{1}{c}{} 	& \multicolumn{1}{c}{Untrusted UI} 	& \multicolumn{1}{c}{Trusted UI} \\ \cline{2-3}
		\multirow{5}{*}{TAs} 	&									& \\
		& Android Key Store					& TrustOTP \\
		& DroidVault 						& TrustDump \\
		& Brasser et al.					& AdAttester \\
		& 									& TrustUI \\
		&									& \\
		\cline{2-3}
		\multirow{5}{*}{GPFR}	&									& \\
		& TLK								& Genode \\
		& OP-TEE 							& T6 \\
		& Andix OS							& TrustICE \\
		& Nokia ObC							& SierraTEE \\
		& TLR 								& Samsung KNOX \\
		&									& \\
		\cline{2-3}
	\end{tabular}
	%}
\end{table}

\subsubsection{Trusted Kernels with Untrusted UI}

Trusted Kernels have the goal of executing generic code in its isolated environment, and most of theses kernels have similar architectures (similar to the one shown in section~\ref{sec:tee}). This architecture is generally composed of a small trusted kernel running in the secure world of TrustZone-enabled processors, a normal world user space client API and a kernel TEE device driver, used to communicate between worlds.

OP-TEE~\cite{op_tee}, TLK~\cite{tlk}, TLR~\cite{santos2011trusted} and AndixOS~\cite{fitzekandix} are \ac{TEE} implementations which share this general architecture. On-board Credentials (ObC)~\cite{kostiainen2012board} is another \ac{TEE} system, originally developed for Nokia mobile devices using the TI M-Shield technology and later ported to ARM's TrustZone, which supports the development of secure credential and authentication mechanisms. Although these systems use TrustZone hardware based isolation to ensure that applications running inside the secure world are not modified by a compromised rich OS, they were implemented with the goal of reducing the \ac{TCB} in order to ensure a less vulnerable system, and for this reason there are some limitations regarding the features they can support.

%TODO ENTREGA
% Estes sistemas não têm publicações associadas?
A reduced \ac{TCB} means that most features of standard mobile operating systems are not supported. For instance, in both TLR and OP-TEE, as well as AndixOS, the secure world kernel lacks drivers for peripherals such as the touchscreen or code to control the framebuffer, thus it is not capable of supporting trusted UI. For this reason, these systems do not allow developers to easily build trusted applications for sensitive data display. Instead, these sytems support an RPC-like mechanism for in-between-world communication, secure persistent storage and basic cryptographic systems allowing for the development of simple trusted services.

\subsubsection{Trusted Services with Untrusted UI}

As opposed to Trusted Kernels, which enable the execution of general-purpose application code on the secure world, Trusted Services are designed to implement specific applications in the secure world natively.
%This subsection describes trusted services which do not support trusted UI, or trusted services which do not require trusted UI to correctly perform its function.
Some trusted services, such as DroidVault and Restricted Spaces, use custom trusted kernels to fully control the underlying hardware and execution environment, whilst designing specific security solutions which may not be supported by generic trusted kernels.

%REVER PARA FACILITAR A LEITURA
A system by Brasser et al.~\cite{brasserregulating}, which will be referred to as Restricted Spaces for the remainder of this section, similarly to CRePE~\cite{conti2011crepe} and MOSES~\cite{russello2012moses}, allows for third parties (hosts) to regulate how users (guests) use their devices (e.g., manage device resources), while in a specific space. This system comprises of authentication and communication mechanisms between the guest's secure world and the host's, and remote memory operations, which allow for configuration changes such as uninstall peripheral drivers, either by pointing their interfaces to NULL, or by pointing them to dummy drivers that just return error codes. With this, Remote Spaces is capable of securely refine device permissions using a context-aware approach.

DroidVault~\cite{li2014droidvault} introduces the notion of data vault, which is an isolated data protection manager running in the trusted domain for secure file management, as a protective measure for sensitive data on Android mobile devices. To achieve this, DroidVault adopts the memory manager and interrupt handler from Open Virtualization's SierraTEE~\cite{sierra_tee} and is implemented with a data protection manager, encryption library and a port of a lightweight SSL/TLS library called PolarSSL~\footnote{https://polarssl.org/}. Much like the trusted application described above, DroidVault supports world switching through software interrupts, secure boot and even inter-world communication. With this Trusted Service a user can download a sensitive file from an authority and securely store it on the device. The sensitive file is encrypted and signed by the data protection manager before it is stored in the untrusted Android OS, in order to save space in the limited storage capacity available at the secure world domain.

Android Key Store~\cite{aks} is another security service in Android. This service allows for cryptographic keys to be stored in a container (keystore), so its extraction from the device becomes difficult and so they can be used for common cryptographic operations. The encryption and decryption of the container is handled by the keystore service, which in turn links with a hardware abstraction layer module called "keymaster". The Android open source project (AOSP) provides a sofware implementation of this module called "softkeymaster", but device vendors can offer support for hardware based protected storage when available by using TrustZone.

These Trusted Services do not fulfil the goals of this project as they do not support necessary features such as secure display. On the other, DroidVault takes an interesting approach to secure storage which may be an inspiration for the secure storage challenge in \emph{ViewZone}.

\subsubsection{Trusted Kernels with Trusted UI}

In this section we describe Trusted Kernels with support for trusted UI. As referenced before, GlobalPlatform defined standard APIs for the communication between the rich OS running in the normal world and the secure OS, but this organization also defined device specifications which TEEs must comply to in order to be certified. Included in these device specifications is a trusted UI clause, meaning that every TEE which complies with GlobalPlatform's device specifications must support trusted UI. 

SierraTEE~\cite{sierra_tee}, T6~\cite{t6_tee} and Open-TEE~\cite{mcgillion2015open} comply with this standard, and for this reason allow the development of trusted applications with secure user interfaces. Open-TEE's trusted UI feature is being developed by the community as it was not originally supported.The Genode OS Framework~\cite{genode} is a tool kit for building highly secure special-purpose operating systems to be executed in TrustZone-enabled processors. Genode implements a framebuffer and input drivers to be used by the secure kernel, thus trusted applications running on top of Genode-based TEEs can offer trusted user interfaces.

Samsung KNOX~\cite{knox_whitepaper} is a defense-grade mobile security platform which provides strong guarantees for the protection of enterprise data. This security is achieved through several layers of data protections which include secure boot, TrustZone-based integrity measurement architecture (TIMA) and Security Enhancements for Android (SEAndroid~\cite{smalley2013security}, which was already discussed in previous sections). Samsung KNOX offers a product called KNOX Workspace, which is a container designed to separate, isolate, encrypt, and protect work data from attackers. This enterprise-ready solution provides management tools and utilities to meet security needs of enterprises large and small. Workspace provides this separate secure environment within the mobile device, complete with its own home screen, launcher, applications, and widgets.

TrustICE~\cite{sun2015trustice} is an isolation framework to provide isolated computing environments (ICEs) on mobile devices. A lot of similar solutions provide isolated computing environments by allowing code to be executed in the secure world, generally in the form of trusted applications. TrustICE aims at creating ICEs in the normal world domain rather than in the secure world. For this reason, TrustICE's architecture is slightly different from those described before.

Figure~\ref{fig:trustICE_architecture} compares TrustICE's architecture with those of traditional TrustZone TEE's, where trusted applications run inside the secure world domain. TrustICE works by implementing a trusted domain controler (TDC) in the secure world, which is responsible for suspending the execution of the rich OS as well as other ICE's in the system when another ICE is running, thus supporting CPU isolation for running ICE's. For memory isolation a watermarking mechanism is implemented so the rich OS cannot access secure code running in the normal world memory. In order to isolate I/O devices the secure world blocks all unnecessary external interrupts from arriving at the TDC, thus protecting the TDC from being interrupted by malicious devices, the exception being a minimal set of required interrupts to allow trusted UI.

Because these systems support secure display and secure storage they are adequate for the development of trusted applications which require sensitive information to be displayed to the user. However, to develop such application is complex because these trusted kernels are not developer friendly and are not build to support applications with this specific goal. For this reason, there is a need to create a trusted service for secure content display.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.80\textwidth]{img/trustICE.pdf}
	\caption{Architecture comparison between traditional TrustZone's software stack and TrustICE (adapted from~\cite{sun2015trustice})}
	\label{fig:trustICE_architecture}
\end{figure}

\subsubsection{Trusted Services with Trusted UI}

Besides Trusted Kernels, some Trusted Services offer secure display to the applications implemented in the secure domain. Usually, this is done by implementing secure display drivers and secure framebuffers in the secure world, thus isolating the resources which support trusted user interfaces.

TrustOTP~\cite{sun2015trustotp} is a One-Time-Password (OTP) system, secured by hardware, where the OTP is generated based on Time and a Counter secured by TrustZone's memory management. Most trusted applications described before require inter-world communication to trigger the world-switching mechanism. This system leverages hardware interrupts to trigger the world-switch. This mitigates denial-of-service attacks by a malicious rich OS which may control the inter-world communication mechanism and intercept the calls (software interrupts) required to trigger the world-switch. 

TrustDump~\cite{sun2015reliable} is a secure memory acquisition tool and offloads the memory through micro-USB. Similarly to TrustOTP, this system relies on hardware interrupts to trigger world-switches. This solution may be implemented by systems which require no inter-world communication, but for systems which need to offer seamless integration with the normal world this approach may have to be leveraged with other development strategies. Both of these systems support trusted UI by implementing secure display and input drivers and display controllers to manage the secure framebuffers.

Instead of implementing the required drivers to support trusted UI, some systems designed mechanisms to allow the reuse of untrusted drivers, implemented in the rich OS, by the secure world domain.
% Melhorar este parágrafo para se perceber de forma mais clara.
TrustUI~\cite{li2014building} excludes the device drivers for input, display and network from the secure world, and instead reuses the existing drivers from the normal world, thus achieving a much smaller TCB than previously described systems. Because we are only interested in secure display, the following explanation discards the network delegation mode and input mechanism. To achieve trusted UI, device drivers are split into two parts: a backend running in the normal world domain and a frontend running in the secure world. Both parts correspond to proxy modules running in both worlds, which communicate via shared memory. Whenever secure display is necessary, the frontend asks for a framebuffer from the backend driver and sets that memory region as secure only, thus isolating the framebuffer from rich OS manipulation. 

Because this mechanism can still be victim of framebuffer overlay attacks, where a malicious backend driver gives a false framebuffer to the secure world, the system randomizes the background and foreground colours used in the display and uses two LEDs, controlled by the secure world, to show these same colours. A user can visually check if the colours shown in the secure LEDs match those of the display. If they match then the user is assured that the display shown is being controlled by the secure world.
%To support trusted input from the user, TrustUI introduces a randomization mechanism to generate different software keyboards for every input of the user. This means a malicious rich OS cannot correctly intercept user input. But a malicious system still disclose, for instance, the length of a password and for this reason, the keyboard mechanism introduces, from time to time, \emph{confirm} buttons randomly positioned on the screen before continuing. This method also prevents fake key injection attacks, where a malicious system would trick the secure world into believing those key strokes were authentic and originated from a real user.

These systems support secure display, as such, they do not disclose sensitive data. However, TrustOTP and TrustDump do not offer a fully integrated environment with the Android running in the normal domain. TrustUI, on the other hand, fully integrates its environment with that of the Android operating system. Furthermore, TrustUI describes a novelty mechanismm for the reuse, by the secure domain, of untrusted driver implemented in the normal world without compromising security, which significantly reduces the secure system's trusted computing base. The main disadvantage of TrustUI is that, similarly to TrustOTP and TrustDump, does not support the development of generic display applications. Besides, TrustUI is not immune to denial-of-service attacks by a malicious operating system running in the normal world, which may compromise the execution of the secure system.